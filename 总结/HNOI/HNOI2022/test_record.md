## 2021/12/13

**Lemon**

首先发现最重要的性质：

> 柠檬形成一个大根堆。

证明：

任意点对 $(x, y)$，其中 $y$ 为 $x$ 父亲。若 $w_x > w_y$，则交换 $w_x, w_y$ 必然不劣于不交换，进行完所有交换操作后，任意父亲 $w$ 不小于儿子 $w$。

先考虑无加固操作情况，由这个性质得到一个朴素做法，建立一个大根堆，维护所有能操作的点集，从大到小放柠檬 $q$，每次取出点集中 $d$ 最大的点 $p$，将柠檬 $q$放到 $p$ 处，弹出 $p$ 并将 $p$ 所有儿子入堆。如果存在某一时刻 $w_q > d_p$，则无解。

有加固操作，在于当第一次遇到 $w_q > d_p$ 时，需要进行加固。无法立刻得出具体加固哪个点，但肯定加固当前在堆中的某个点。

引入一个判定的方法，记 $s_i = \min \{ s_{fa}, d_i \}$，特别有 $s_1 = d_1$。那么 柠檬 $j$ 能放在结点 $i$ 当且仅当 $w_j \leq s_i$。然后一定 $s, w$ 大配大，小配小，把 $s, w$ 看作是值域数轴上的一些 $+1(s), -1(w)$，当且仅当任意位置 $S_+ \geq S_-$，即对于每个 $w_j$，比它大的 $s_i$ 数量记作 $c_j$，需满足 $c_i \geq i$。维护全局 $c_i - i$ 最小值即可。

回头看到可能加固的所有点，实际上可以枚举加固哪一个，然后遍历其子树更新 $s$，并进行判定，最后还原。由于堆中点的子树互不相交，总时间复杂度 $O(n \log n)$。

**Triplet**

发现可以通过询问 $5$ 个元素中所有三元组确定每个元素。然后任选其中三元素，设为 $a, b, c(a < b < c)$。

考虑确定其他元素（设为 $x$），如果 $x < a$ 或 $x > b$，可以通过一次查询 $(a, b, x)$ 求得。否则再查询 $(b, c, x)$。一个优化是当 $a < x < b$ 时用 $x$ 去更新 $a$ 或 $b$，使得 $[a, b]$ 长度减半。这样复杂度是 $O(n + \log V)$。

## 2021/12/14

**C**

一个操作：  
对于一个点集 $S$ 和点集外一点 $x$，可以通过二分以 $O(\log |S|)$ 求出点集中一点 $y$ 在 $x$ 子树中（前提 $y$ 存在）。

看到这题有个模糊的思路是大致确定树中点之间的拓扑关系。用 DFS 使用上面的操作从 $x$ 转移到 $y$ 从而建出一个搜索树，每个点有**回溯时间戳** $\mathrm{dfn}$。  

这个搜索树有个性质，就是对于原树上两点 $a,b$，若 $a$ 为 $b$ 祖先，则 $\mathrm{dfn}(a) > \mathrm{dfn}(b)$。  

进一步的，在点 $p$ 回溯前把他丢到点集 $T$ 中，表示他需要找爸爸。同时需要处理 $T$ 中其他已有点的请求，即考虑 $p$ 是 $T$ 中哪些点的爸爸。这也可以使用上面的操作找到，记得把找到的儿子从点集中去除。  
正确性证明：  
证明每个点 $y$ 只会在其父亲 $fa_y$ 处被找到。首先 $y$ 只有可能在 $fa_y, fa_{fa_y}, \dots, 1$ 处被找到。而 $fa_y$ 的 $\mathrm{dfn}$ 在 $y$ 的祖先中最小（由上面性质得到），因此 $fa_y$ 最先找到 $y$，并删去，$y$ 的更高祖先不会找到 $y$。正确性得证。

## 2021/12/16

**rehearsal**

考虑每对点 $(i, j)(i<j)$，$j$ 能获得 $i$ 的经验当且仅当不存在 $k$ 使得 $s_i < s_k < s_j$。  
使用 CDQ 分治，当前分治到 $[l, r]$，只计算 $[l, mid]$ 对 $[mid + 1, r]$ 的贡献。记 $x_i(i \in [l, mid])$ 为 $[i + 1, mid]$ 中 $>x_i$ 的最小 $x$（没有则为 $\infty$），$y_i(i \in [mid + 1, r])$ 为 $[mid + 1, i-1]$ 中 $<x_i$ 的最大 $x$。（没有则为 $0$）  

$i$ 能对 $j$ 贡献当且仅当 $i < j, s_i < s_j, x_i > s_j, s_i > y_j$，四维偏序问题，$O(n \log^3 n)$ 求解。

**strategy**

定义 $x < y$ 当且仅当 $t_x < t_y$  
对于 $t$ 相同的人，题目说任选一个，这里钦定选最靠前的那个。

一个重要性质：$i$ 能于前 $p$ 个进入亭子当且仅当 $k + p - 1$ 至少有 $k-1$ 个人大于 $i$。  
证明：  
$k+p-1$ 中最大的 $k-1$ 个人，在任意时刻都不会进亭。最坏情况下，考虑 $i$ 在前 $p-1$ 进不了，在第 $p$ 人时，现在等待的 $k$ 人一定是最大的 $k-1$ 人和 $i$，那么 $i$ 一定能第 $p$ 个进亭。

将这个性质进一步推广：选了 $p$ 个人就是选了前 $k+p-1$ 人中前 $p$ 小的所有人。

考虑计算每一对人 $x, y (x < y)$ 的贡献，如果求出 $x$ 比 $y$ 先离开的概率为 $P$，那么答案应加上 $P \times t_x + (1-P) \times t_y$ 的贡献。

求 $P$ 相当于求有多少个初始等待顺序满足 $x$ 比 $y$ 先离开。
* 如果 $x$ 在 $y$ 前面，那么一定满足条件。
* 否则，必须保证 $x$ 前面不存在 $\geq k-1$ 个人大于 $y$。

两者都可以通过简单的排列组合知识求出。

**library**

答案等于总共的回文子序列数-本质不同回文子序列数，DP 求解，$O(n^2)$

## 2021/12/17

**min**

数据伪随机，每次操作每个点的概率是 $\frac{1}{n}$。考虑这样一种做法，维护 $\min$ 值，当修改的点是 $\min$ 时暴力扫一遍，由于期望下每 $n$ 次才会修改到 $\min$ 一次，于是期望复杂度 $O(m)$。

**string**

编辑距离的变种，题目的特殊约束说明不存在连续的交换操作，仍然可以用 DP 求解。

**sequence**

对每个点维护 $pre$ 表示其上一个颜色相同的位置，那么一次询问相当于求 $\sum_{i=l}^r [pre(i) < l]$。  

修改操作为区间覆盖，考虑颜色段均摊，每次最多增加 $2$ 个颜色段，总段数是 $O(n+m)$ 级，每次删去被新段完全覆盖的段，每段最多删一次，总共删除次数也是 $O(n+m)$ 的。用 set 维护所有段。此外，$pre$ 的变化与增加的段数是正相关的，因此 $pre$ 的变化也是 $O(n+m)$ 级别的。可以都当作单点修改。结合上面的询问就是三维偏序，用 CDQ 分治求解，复杂度 $O(n \log^2 n)$。

## 2021/12/18

**score**

邻项交换可得最优的策略是按 $\frac{a_i}{t_i}$ 降序解题，对于每一个 $\frac{a_i}{t_i}$ 相等的段，可以求出每道题的最早时间和最晚时间。  
由于答案具有单调性，可以二分，然后按 $a_i$ 从小到大扫，如有逆序对则不合法。复杂度 $O(n \log n)$

**travel**

发现最优路线在 $x, y$ 上总有一维是单调的。假设 $x$ 维是单调的，于是只需维护 $y$ 维上的最短路线。用 set 维护路线，从左到右扫每个矩形，取出 set 中被该矩形挡住的所有路线，更新最优的两条分别往上/下走，删掉其余的路线。摊还分析复杂度是 $O(n \log n)$ 的。

## 2021/12/20

**交友**

建立最小割模型，每个点 $v_i$ 连 $(v_i, T, lim)$, 每条边 $e_i$ 连 $(S, e_i, 1)$, 假设其连接端点为 $x, y$，连 $(e_i, x, \infty)$ 与 $(e_i, y, \infty)$。  
割 $e_i$ 表示不选此边，割 $v_i$ 表示选该点。最小割 $mincut = \min \{ m - |e(s)| + lim|s| \} = m + \min \{ lim|s| - |e(s)| \}$。

考虑所求为 $\max \{ |e(s)| - lim|s| \} + lim = m - mincut + lim$。

但由于直接流可能一个点也不选，因此需要枚举每个点，钦定选择该点。具体操作是先退回流经点的流量，然后将该点与 $T$ 连边容量设为 $0$，再从源点增广退回的流量。由于边容量 $\leq lim$，总复杂度看作是 $O(n(n+m) lim)$。

**弱化的杨表**

将题意转化为在一个长 $2n$ 的序列中放 $n$ 个左括号和 $n$ 个右括号，每个位置作为左括号的代价为 $a$，右括号的代价为 $b$。求最小代价。

带悔贪心的思想，不断维护前 $2i$ 个括号的合法序列，用增量法考虑添加两个新的相邻位置 $x, y(y=x+1)$。首先可以在 $x, y$ 处都放右括号。此时必须从前 $2i$ 个括号中找到一个右括号将其变成左括号，这样就能腾出两个左括号（一个是由右括号变来的，一个是和右括号原来匹配的），与 $x, y$ 匹配即可。正确性自证。  
贪心地，每次一定会找 $a-b$ 最小的右括号变左括号。用堆维护所有右括号和他的转化代价即可。

2021/12/21

**treasure**

考虑每个点 $x$ 的期望贡献，当且仅当根到 $x$ 的路径依次访问，即有 $dep (x)$ 个点必须维持相对顺序。考虑在 $n$ 个位置中任取 $dep (x)$ 个位置，这 $dep (x)$ 个点填进去共有 $dep (x)!$ 种顺序，但 $x$ 有贡献的只有一种，即 $x$  的期望贡献为 $\frac{1}{dep(x)!}$。另外注意特判环上点。

**footprint**

发现最优的方案中不存在连续的回头，即方案是由若干条往前走的链首尾拼接起来。由此可求得答案下界，即为最小链覆盖。  
进行完链覆盖后得到了一堆链，将其分类为 LL、LR、RL、RR 表示首尾的字符。考虑能否构造出一个合法方案，若合法显然最优。  

由于 LL 和 RR 的数量差不大于 $1$（大于 $1$ 时 L 和 R 数量差大于 $1$，不符题意）。可以先把 LL 和 RR 合并，最后只有可能得到 LL 或 RR 或 LR。  
然后把所有 LR 合并成一个大LR，所有 RL 合并成一个大RL，把 大LR 或 大RL 靠后的末尾接到对面的末尾，得到一个 LL 和 RR，合并成 LR。然后与上面得到的 LL 或 RR 合并即得到答案。