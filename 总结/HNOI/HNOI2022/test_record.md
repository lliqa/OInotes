## 2021/12/13

**Lemon**

首先发现最重要的性质：

> 柠檬形成一个大根堆。

证明：

任意点对 $(x, y)$，其中 $y$ 为 $x$ 父亲。若 $w_x > w_y$，则交换 $w_x, w_y$ 必然不劣于不交换，进行完所有交换操作后，任意父亲 $w$ 不小于儿子 $w$。

先考虑无加固操作情况，由这个性质得到一个朴素做法，建立一个大根堆，维护所有能操作的点集，从大到小放柠檬 $q$，每次取出点集中 $d$ 最大的点 $p$，将柠檬 $q$放到 $p$ 处，弹出 $p$ 并将 $p$ 所有儿子入堆。如果存在某一时刻 $w_q > d_p$，则无解。

有加固操作，在于当第一次遇到 $w_q > d_p$ 时，需要进行加固。无法立刻得出具体加固哪个点，但肯定加固当前在堆中的某个点。

引入一个判定的方法，记 $s_i = \min \{ s_{fa}, d_i \}$，特别有 $s_1 = d_1$。那么 柠檬 $j$ 能放在结点 $i$ 当且仅当 $w_j \leq s_i$。然后一定 $s, w$ 大配大，小配小，把 $s, w$ 看作是值域数轴上的一些 $+1(s), -1(w)$，当且仅当任意位置 $S_+ \geq S_-$，即对于每个 $w_j$，比它大的 $s_i$ 数量记作 $c_j$，需满足 $c_i \geq i$。维护全局 $c_i - i$ 最小值即可。

回头看到可能加固的所有点，实际上可以枚举加固哪一个，然后遍历其子树更新 $s$，并进行判定，最后还原。由于堆中点的子树互不相交，总时间复杂度 $O(n \log n)$。

**Triplet**

发现可以通过询问 $5$ 个元素中所有三元组确定每个元素。然后任选其中三元素，设为 $a, b, c(a < b < c)$。

考虑确定其他元素（设为 $x$），如果 $x < a$ 或 $x > b$，可以通过一次查询 $(a, b, x)$ 求得。否则再查询 $(b, c, x)$。一个优化是当 $a < x < b$ 时用 $x$ 去更新 $a$ 或 $b$，使得 $[a, b]$ 长度减半。这样复杂度是 $O(n + \log V)$。

## 2021/12/14

**C**

一个操作：  
对于一个点集 $S$ 和点集外一点 $x$，可以通过二分以 $O(\log |S|)$ 求出点集中一点 $y$ 在 $x$ 子树中（前提 $y$ 存在）。

看到这题有个模糊的思路是大致确定树中点之间的拓扑关系。用 DFS 使用上面的操作从 $x$ 转移到 $y$ 从而建出一个搜索树，每个点有**回溯时间戳** $\mathrm{dfn}$。  

这个搜索树有个性质，就是对于原树上两点 $a,b$，若 $a$ 为 $b$ 祖先，则 $\mathrm{dfn}(a) > \mathrm{dfn}(b)$。  

进一步的，在点 $p$ 回溯前把他丢到点集 $T$ 中，表示他需要找爸爸。同时需要处理 $T$ 中其他已有点的请求，即考虑 $p$ 是 $T$ 中哪些点的爸爸。这也可以使用上面的操作找到，记得把找到的儿子从点集中去除。  
正确性证明：  
证明每个点 $y$ 只会在其父亲 $fa_y$ 处被找到。首先 $y$ 只有可能在 $fa_y, fa_{fa_y}, \dots, 1$ 处被找到。而 $fa_y$ 的 $\mathrm{dfn}$ 在 $y$ 的祖先中最小（由上面性质得到），因此 $fa_y$ 最先找到 $y$，并删去，$y$ 的更高祖先不会找到 $y$。正确性得证。

## 2021/12/16

**rehearsal**

考虑每对点 $(i, j)(i<j)$，$j$ 能获得 $i$ 的经验当且仅当不存在 $k$ 使得 $s_i < s_k < s_j$。  
使用 CDQ 分治，当前分治到 $[l, r]$，只计算 $[l, mid]$ 对 $[mid + 1, r]$ 的贡献。记 $x_i(i \in [l, mid])$ 为 $[i + 1, mid]$ 中 $>x_i$ 的最小 $x$（没有则为 $\infty$），$y_i(i \in [mid + 1, r])$ 为 $[mid + 1, i-1]$ 中 $<x_i$ 的最大 $x$。（没有则为 $0$）  

$i$ 能对 $j$ 贡献当且仅当 $i < j, s_i < s_j, x_i > s_j, s_i > y_j$，四维偏序问题，$O(n \log^3 n)$ 求解。

**strategy**

定义 $x < y$ 当且仅当 $t_x < t_y$  
对于 $t$ 相同的人，题目说任选一个，这里钦定选最靠前的那个。

一个重要性质：$i$ 能于前 $p$ 个进入亭子当且仅当 $k + p - 1$ 至少有 $k-1$ 个人大于 $i$。  
证明：  
$k+p-1$ 中最大的 $k-1$ 个人，在任意时刻都不会进亭。最坏情况下，考虑 $i$ 在前 $p-1$ 进不了，在第 $p$ 人时，现在等待的 $k$ 人一定是最大的 $k-1$ 人和 $i$，那么 $i$ 一定能第 $p$ 个进亭。

将这个性质进一步推广：选了 $p$ 个人就是选了前 $k+p-1$ 人中前 $p$ 小的所有人。

考虑计算每一对人 $x, y (x < y)$ 的贡献，如果求出 $x$ 比 $y$ 先离开的概率为 $P$，那么答案应加上 $P \times t_x + (1-P) \times t_y$ 的贡献。

求 $P$ 相当于求有多少个初始等待顺序满足 $x$ 比 $y$ 先离开。
* 如果 $x$ 在 $y$ 前面，那么一定满足条件。
* 否则，必须保证 $x$ 前面不存在 $\geq k-1$ 个人大于 $y$。

两者都可以通过简单的排列组合知识求出。

**library**

答案等于总共的回文子序列数-本质不同回文子序列数，DP 求解，$O(n^2)$

## 2021/12/17

**min**

数据伪随机，每次操作每个点的概率是 $\frac{1}{n}$。考虑这样一种做法，维护 $\min$ 值，当修改的点是 $\min$ 时暴力扫一遍，由于期望下每 $n$ 次才会修改到 $\min$ 一次，于是期望复杂度 $O(m)$。

**string**

编辑距离的变种，题目的特殊约束说明不存在连续的交换操作，仍然可以用 DP 求解。

**sequence**

对每个点维护 $pre$ 表示其上一个颜色相同的位置，那么一次询问相当于求 $\sum_{i=l}^r [pre(i) < l]$。  

修改操作为区间覆盖，考虑颜色段均摊，每次最多增加 $2$ 个颜色段，总段数是 $O(n+m)$ 级，每次删去被新段完全覆盖的段，每段最多删一次，总共删除次数也是 $O(n+m)$ 的。用 set 维护所有段。此外，$pre$ 的变化与增加的段数是正相关的，因此 $pre$ 的变化也是 $O(n+m)$ 级别的。可以都当作单点修改。结合上面的询问就是三维偏序，用 CDQ 分治求解，复杂度 $O(n \log^2 n)$。

## 2021/12/18

**score**

邻项交换可得最优的策略是按 $\frac{a_i}{t_i}$ 降序解题，对于每一个 $\frac{a_i}{t_i}$ 相等的段，可以求出每道题的最早时间和最晚时间。  
由于答案具有单调性，可以二分，然后按 $a_i$ 从小到大扫，如有逆序对则不合法。复杂度 $O(n \log n)$

**travel**

发现最优路线在 $x, y$ 上总有一维是单调的。假设 $x$ 维是单调的，于是只需维护 $y$ 维上的最短路线。用 set 维护路线，从左到右扫每个矩形，取出 set 中被该矩形挡住的所有路线，更新最优的两条分别往上/下走，删掉其余的路线。摊还分析复杂度是 $O(n \log n)$ 的。

## 2021/12/20

**交友**

建立最小割模型，每个点 $v_i$ 连 $(v_i, T, lim)$, 每条边 $e_i$ 连 $(S, e_i, 1)$, 假设其连接端点为 $x, y$，连 $(e_i, x, \infty)$ 与 $(e_i, y, \infty)$。  
割 $e_i$ 表示不选此边，割 $v_i$ 表示选该点。最小割 $mincut = \min \{ m - |e(s)| + lim|s| \} = m + \min \{ lim|s| - |e(s)| \}$。

考虑所求为 $\max \{ |e(s)| - lim|s| \} + lim = m - mincut + lim$。

但由于直接流可能一个点也不选，因此需要枚举每个点，钦定选择该点。具体操作是先退回流经点的流量，然后将该点与 $T$ 连边容量设为 $0$，再从源点增广退回的流量。由于边容量 $\leq lim$，总复杂度看作是 $O(n(n+m) lim)$。

**弱化的杨表**

将题意转化为在一个长 $2n$ 的序列中放 $n$ 个左括号和 $n$ 个右括号，每个位置作为左括号的代价为 $a$，右括号的代价为 $b$。求最小代价。

带悔贪心的思想，不断维护前 $2i$ 个括号的合法序列，用增量法考虑添加两个新的相邻位置 $x, y(y=x+1)$。首先可以在 $x, y$ 处都放右括号。此时必须从前 $2i$ 个括号中找到一个右括号将其变成左括号，这样就能腾出两个左括号（一个是由右括号变来的，一个是和右括号原来匹配的），与 $x, y$ 匹配即可。正确性自证。  
贪心地，每次一定会找 $a-b$ 最小的右括号变左括号。用堆维护所有右括号和他的转化代价即可。

## 2021/12/21

**treasure**

考虑每个点 $x$ 的期望贡献，当且仅当根到 $x$ 的路径依次访问，即有 $dep (x)$ 个点必须维持相对顺序。考虑在 $n$ 个位置中任取 $dep (x)$ 个位置，这 $dep (x)$ 个点填进去共有 $dep (x)!$ 种顺序，但 $x$ 有贡献的只有一种，即 $x$  的期望贡献为 $\frac{1}{dep(x)!}$。另外注意特判环上点。

**footprint**

发现最优的方案中不存在连续的回头，即方案是由若干条往前走的链首尾拼接起来。由此可求得答案下界，即为最小链覆盖。  
进行完链覆盖后得到了一堆链，将其分类为 LL、LR、RL、RR 表示首尾的字符。考虑能否构造出一个合法方案，若合法显然最优。  

由于 LL 和 RR 的数量差不大于 $1$（大于 $1$ 时 L 和 R 数量差大于 $1$，不符题意）。可以先把 LL 和 RR 合并，最后只有可能得到 LL 或 RR 或 LR。  
然后把所有 LR 合并成一个大LR，所有 RL 合并成一个大RL，把 大LR 或 大RL 靠后的末尾接到对面的末尾，得到一个 LL 和 RR，合并成 LR。然后与上面得到的 LL 或 RR 合并即得到答案。

**points**

一个引理：$a^2 \equiv a \pmod 2$

两个点冲突当且仅当 ${\Delta x}^2 + {\Delta y}^2 = D$，由上述引理可得 ${\Delta x} + {\Delta y} \equiv D \pmod 2$。

可以预先将所有点奇偶染色。  
* 如果 $D$ 是奇数，那么冲突只会在异色点之间。
* 否则，冲突只会在同色点之间。把所有同色点（仅考虑奇色）拿出来，斜 $45 \degree$ 看，相当于是一个菱形。把这个菱形建一个新坐标系，单位长度是原坐标系的 $\sqrt{2}$ 倍。并且在新坐标系中 $D \to \frac{D}{2}$。进一步的，如果连续两次旋转，又会转正，此时原坐标系中的点坐标 $(x, y) \to (\frac{x}{2}, \frac{y}{2})$（画图体会）。  

综上，做法如下：

不断将 $D$ 除以 $4$，设 其含 $4$ 因子 $k$ 个。  
最后，若 $D$ 为奇数，相当于将所有点按 $\lfloor \frac x{2^k}\rfloor + \lfloor \frac y{2^k}\rfloor$ 奇偶分类，否则按 $\lfloor \frac x{2^k}\rfloor$ 奇偶分类。一共有两个 $D$，把所有点分成了四类，选最多的一类即可。（由鸽巢原理可知一定存在解）

## 2021/12/23

**travel**

要特别注意到点权一定为正。

几个性质：

> 一定存在最优方案至少经过一个叶节点，且起点是叶结点。

证明：
* 对于一个方案，如果不经过叶节点，那么结尾点一定能往下走到一个未被经过的叶节点，答案变大。
* 如果一个方案起点 $x$ 不是叶节点，那么把起点设为 $x$ 子树中叶节点一定不劣。

> 一定存在最优方案，每次往祖先走只会走深度最大的未访问点。

证明：

假设当前点深度最大的未访问祖先为 $x$，深度较小的为 $y$。如果走 $y$ 而不走 $x$，分情况讨论：
* 如果以后会访问 $x$ 子树点，那么不如一开始先走 $x$，然后访问子树点，最后走到 $y$，不劣。
* 如果以后不会访问 $x$ 子树点，那么先走 $x$ 再走 $y$ 相较于原方案多了 $x$ 的贡献，更优。

根据上面两个性质，可以确定大致的维护顺序：从下往上。

考虑次下层点 $x$，其所有儿子均为叶结点。如果起点在 $x$ 儿子中，一定选择点权最大的点 $A_{\max}$ 出发，然后向上走到 $x$，再向下走到次大点 $A_{\sec}$。可以把此三者缩成一个大点 $A_{new} = A_x + A_{\max} + A_{\sec}$。把 $A_{new}$ 和 $x$ 的其他儿子放到一起考虑，他们相当于一个新的点集，走了其中一个后就必须向上走 $x$ 的祖先（因为 $x$ 被包含在 $A_{new}$ 中），可以理解成把这些点挂到 $fa_x$ 上去，把这些点看作新一轮的叶节点， $fa_x$ 则变成了次下层点。

用 $set$ 维护所有点，点数 $O(n)$ 级，要支持合并两个点集，用启发式合并，复杂度 $O(n \log^2 n)$。

## 2021/12/24

**background**

分析 $a$ 序列中的性质，考察 $a$ 序列中的所有 $x$ 位数 $\overline{p_1p_2\dots p_x}$，如果不考虑个位，把剩下的 $x-1$ 位看作是 $x-1$ 位数 $\overline{p_1p_2\dots p_{x-1}}$，那么这个数是可以取遍所有 $x-1$ 位数的。  
原因在于每次加的 $\operatorname{maxdigit}$ 是 $[0, 10)$ 的整数，导致每次个位**最多**进位一次，相当于前 $x-1$ 位构成的 $x-1$ 位数每次最多加一。又由于序列 $a$ 首项是 $1$，因此所有 $x-1$ 位数都能遍历到。

由上面的分析可以想到判定一个数是否属于序列 $a$ 的方法。  
设状态 $f (x, y)$，表示 $a$ 序列中是否存在一个数 $\overline{p_1p_2\dots p_n}$ 满足 $x = \overline{p_1p_2\dots p_{n-1}}$ 且 $y = p_n$，若存在则为真，否则为假。转移显然。  
但这个东西还是没什么用。考虑优化，每次操作会加上 $\operatorname{maxdigit}$，如果从高位往低位地确定每一位，假设现在到了第 $i$ 位，其实并不关心更高位的具体取值，只要知道更高位的 $\operatorname{maxdigit}$ 记为 $vx$ 即可。还需要知道此时个位 $vf$。于是可以设状态 $f (vx, i, vi, vf)$ 表示当前考虑到第 $i$ 位，更高位 $\operatorname{maxdigit} = vx$，个位为 $vf$，第 $i$ 位 $0 \to vi$ 后个位会变成什么。转移也不难实现，同时维护一个状态 $nxt (vx, i, vf)$，变量意义同上，表示要让第 $i+1$ 位 $+1$ 后个位的新取值。

有了上面的状态，就能在 $O(|\texttt{位数}|)$ 的时间内判断一个数是否属于序列 $a$。解决了判定问题，想要计数也不是难事，设 $dp (p, vx, i, vf)$ 表示当前在 $p$ 点，填到第 $i$ 位，该怎么来就怎么来。

## 2021/12/25

**骨灰**

乱搞，复杂度分析

**智子**

打表 $\mathrm{SG}$ 函数，找规律。

**墓地**

根据版本之间的继承关系可以建出一个树形结构，称之为版本树（根为 $0$）。  
版本树上每个点代表的版本的正确物品，为执行完根到该点路径上所有操作后的物品，而每个操作（视为删除一个物品并添加一个新物品）只会影响一个子树。  
自然想到对版本树的 DFS 序维护线段树分治，树上每个点只会在进入时执行一次操作，并在回溯时撤回操作，产生的区间总数是 $O(n+q)$ 的。加入物品时用单调队列优化多重背包，总复杂度 $O((n+q)m \log q)$

## 2021/12/28

**计树**

考虑每个置换环，可以通过手玩或分析得到几个性质：

1. 环长 $>2$ 的环内不能有边。
2. 两长为 $n, m(n < m)$ 的环能相连必须满足 $n \mid m$。
3. 任意环长为 $n$ 的环只能与至多一个环长 $<n$ 的环相连。
4. 两环相连的方案数有 $\gcd (n, m)$ 种。

不难想到按环长从小到大处理，维护一棵树（根环长 $\leq 2$）并不断加入新环。对于一堆环长相等的环（设环长为 $n$）一起处理，找到树上所有能连的祖先点（即为 $n$ 的因数），这些环如果连树上点 $m(m \mid n)$，那么贡献是 $m$，内部连边贡献是 $n$。枚举与树上点的连边树然后 prufer 序列统计答案。

**先辈的游戏**

考虑每个联通块长啥样。发现一定是一个 $\rho$ 型。由于存在优先级的问题，环长最多为 $2$。因此二元环的个数就是连通块的数量。考虑每个二元环的期望贡献即可。