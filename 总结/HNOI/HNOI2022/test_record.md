## 2021/12/13

**Lemon**

首先发现最重要的性质：

> 柠檬形成一个大根堆。

证明：

任意点对 $(x, y)$，其中 $y$ 为 $x$ 父亲。若 $w_x > w_y$，则交换 $w_x, w_y$ 必然不劣于不交换，进行完所有交换操作后，任意父亲 $w$ 不小于儿子 $w$。

先考虑无加固操作情况，由这个性质得到一个朴素做法，建立一个大根堆，维护所有能操作的点集，从大到小放柠檬 $q$，每次取出点集中 $d$ 最大的点 $p$，将柠檬 $q$放到 $p$ 处，弹出 $p$ 并将 $p$ 所有儿子入堆。如果存在某一时刻 $w_q > d_p$，则无解。

有加固操作，在于当第一次遇到 $w_q > d_p$ 时，需要进行加固。无法立刻得出具体加固哪个点，但肯定加固当前在堆中的某个点。

引入一个判定的方法，记 $s_i = \min \{ s_{fa}, d_i \}$，特别有 $s_1 = d_1$。那么 柠檬 $j$ 能放在结点 $i$ 当且仅当 $w_j \leq s_i$。然后一定 $s, w$ 大配大，小配小，把 $s, w$ 看作是值域数轴上的一些 $+1(s), -1(w)$，当且仅当任意位置 $S_+ \geq S_-$，即对于每个 $w_j$，比它大的 $s_i$ 数量记作 $c_j$，需满足 $c_i \geq i$。维护全局 $c_i - i$ 最小值即可。

回头看到可能加固的所有点，实际上可以枚举加固哪一个，然后遍历其子树更新 $s$，并进行判定，最后还原。由于堆中点的子树互不相交，总时间复杂度 $O(n \log n)$。

**Triplet**

发现可以通过询问 $5$ 个元素中所有三元组确定每个元素。然后任选其中三元素，设为 $a, b, c(a < b < c)$。

考虑确定其他元素（设为 $x$），如果 $x < a$ 或 $x > b$，可以通过一次查询 $(a, b, x)$ 求得。否则再查询 $(b, c, x)$。一个优化是当 $a < x < b$ 时用 $x$ 去更新 $a$ 或 $b$，使得 $[a, b]$ 长度减半。这样复杂度是 $O(n + \log V)$。

## 2021/12/14

**C**

一个操作：  
对于一个点集 $S$ 和点集外一点 $x$，可以通过二分以 $O(\log |S|)$ 求出点集中一点 $y$ 在 $x$ 子树中（前提 $y$ 存在）。

看到这题有个模糊的思路是大致确定树中点之间的拓扑关系。用 DFS 使用上面的操作从 $x$ 转移到 $y$ 从而建出一个搜索树，每个点有**回溯时间戳** $\mathrm{dfn}$。  

这个搜索树有个性质，就是对于原树上两点 $a,b$，若 $a$ 为 $b$ 祖先，则 $\mathrm{dfn}(a) > \mathrm{dfn}(b)$。  

进一步的，在点 $p$ 回溯前把他丢到点集 $T$ 中，表示他需要找爸爸。同时需要处理 $T$ 中其他已有点的请求，即考虑 $p$ 是 $T$ 中哪些点的爸爸。这也可以使用上面的操作找到，记得把找到的儿子从点集中去除。  
正确性证明：  
证明每个点 $y$ 只会在其父亲 $fa_y$ 处被找到。首先 $y$ 只有可能在 $fa_y, fa_{fa_y}, \dots, 1$ 处被找到。而 $fa_y$ 的 $\mathrm{dfn}$ 在 $y$ 的祖先中最小（由上面性质得到），因此 $fa_y$ 最先找到 $y$，并删去，$y$ 的更高祖先不会找到 $y$。正确性得证。