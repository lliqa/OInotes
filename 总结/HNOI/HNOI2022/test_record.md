## 2021/12/13

**Lemon**

首先发现最重要的性质：

> 柠檬形成一个大根堆。

证明：

任意点对 $(x, y)$，其中 $y$ 为 $x$ 父亲。若 $w_x > w_y$，则交换 $w_x, w_y$ 必然不劣于不交换，进行完所有交换操作后，任意父亲 $w$ 不小于儿子 $w$。

先考虑无加固操作情况，由这个性质得到一个朴素做法，建立一个大根堆，维护所有能操作的点集，从大到小放柠檬 $q$，每次取出点集中 $d$ 最大的点 $p$，将柠檬 $q$放到 $p$ 处，弹出 $p$ 并将 $p$ 所有儿子入堆。如果存在某一时刻 $w_q > d_p$，则无解。

有加固操作，在于当第一次遇到 $w_q > d_p$ 时，需要进行加固。无法立刻得出具体加固哪个点，但肯定加固当前在堆中的某个点。

引入一个判定的方法，记 $s_i = \min \{ s_{fa}, d_i \}$，特别有 $s_1 = d_1$。那么 柠檬 $j$ 能放在结点 $i$ 当且仅当 $w_j \leq s_i$。然后一定 $s, w$ 大配大，小配小，把 $s, w$ 看作是值域数轴上的一些 $+1(s), -1(w)$，当且仅当任意位置 $S_+ \geq S_-$，即对于每个 $w_j$，比它大的 $s_i$ 数量记作 $c_j$，需满足 $c_i \geq i$。维护全局 $c_i - i$ 最小值即可。

回头看到可能加固的所有点，实际上可以枚举加固哪一个，然后遍历其子树更新 $s$，并进行判定，最后还原。由于堆中点的子树互不相交，总时间复杂度 $O(n \log n)$。

**Triplet**

发现可以通过询问 $5$ 个元素中所有三元组确定每个元素。然后任选其中三元素，设为 $a, b, c(a < b < c)$。

考虑确定其他元素（设为 $x$），如果 $x < a$ 或 $x > b$，可以通过一次查询 $(a, b, x)$ 求得。否则再查询 $(b, c, x)$。一个优化是当 $a < x < b$ 时用 $x$ 去更新 $a$ 或 $b$，使得 $[a, b]$ 长度减半。这样复杂度是 $O(n + \log V)$。

## 2021/12/14

**C**

一个操作：  
对于一个点集 $S$ 和点集外一点 $x$，可以通过二分以 $O(\log |S|)$ 求出点集中一点 $y$ 在 $x$ 子树中（前提 $y$ 存在）。

看到这题有个模糊的思路是大致确定树中点之间的拓扑关系。用 DFS 使用上面的操作从 $x$ 转移到 $y$ 从而建出一个搜索树，每个点有**回溯时间戳** $\mathrm{dfn}$。  

这个搜索树有个性质，就是对于原树上两点 $a,b$，若 $a$ 为 $b$ 祖先，则 $\mathrm{dfn}(a) > \mathrm{dfn}(b)$。  

进一步的，在点 $p$ 回溯前把他丢到点集 $T$ 中，表示他需要找爸爸。同时需要处理 $T$ 中其他已有点的请求，即考虑 $p$ 是 $T$ 中哪些点的爸爸。这也可以使用上面的操作找到，记得把找到的儿子从点集中去除。  
正确性证明：  
证明每个点 $y$ 只会在其父亲 $fa_y$ 处被找到。首先 $y$ 只有可能在 $fa_y, fa_{fa_y}, \dots, 1$ 处被找到。而 $fa_y$ 的 $\mathrm{dfn}$ 在 $y$ 的祖先中最小（由上面性质得到），因此 $fa_y$ 最先找到 $y$，并删去，$y$ 的更高祖先不会找到 $y$。正确性得证。

## 2021/12/16

**rehearsal**

考虑每对点 $(i, j)(i<j)$，$j$ 能获得 $i$ 的经验当且仅当不存在 $k$ 使得 $s_i < s_k < s_j$。  
使用 CDQ 分治，当前分治到 $[l, r]$，只计算 $[l, mid]$ 对 $[mid + 1, r]$ 的贡献。记 $x_i(i \in [l, mid])$ 为 $[i + 1, mid]$ 中 $>x_i$ 的最小 $x$（没有则为 $\infty$），$y_i(i \in [mid + 1, r])$ 为 $[mid + 1, i-1]$ 中 $<x_i$ 的最大 $x$。（没有则为 $0$）  

$i$ 能对 $j$ 贡献当且仅当 $i < j, s_i < s_j, x_i > s_j, s_i > y_j$，四维偏序问题，$O(n \log^3 n)$ 求解。

**strategy**

定义 $x < y$ 当且仅当 $t_x < t_y$  
对于 $t$ 相同的人，题目说任选一个，这里钦定选最靠前的那个。

一个重要性质：$i$ 能于前 $p$ 个进入亭子当且仅当 $k + p - 1$ 至少有 $k-1$ 个人大于 $i$。  
证明：  
$k+p-1$ 中最大的 $k-1$ 个人，在任意时刻都不会进亭。最坏情况下，考虑 $i$ 在前 $p-1$ 进不了，在第 $p$ 人时，现在等待的 $k$ 人一定是最大的 $k-1$ 人和 $i$，那么 $i$ 一定能第 $p$ 个进亭。

将这个性质进一步推广：选了 $p$ 个人就是选了前 $k+p-1$ 人中前 $p$ 小的所有人。

考虑计算每一对人 $x, y (x < y)$ 的贡献，如果求出 $x$ 比 $y$ 先离开的概率为 $P$，那么答案应加上 $P \times t_x + (1-P) \times t_y$ 的贡献。

求 $P$ 相当于求有多少个初始等待顺序满足 $x$ 比 $y$ 先离开。
* 如果 $x$ 在 $y$ 前面，那么一定满足条件。
* 否则，必须保证 $x$ 前面不存在 $\geq k-1$ 个人大于 $y$。

两者都可以通过简单的排列组合知识求出。

**library**

答案等于总共的回文子序列数-本质不同回文子序列数，DP 求解，$O(n^2)$

## 2021/12/17

**min**

数据伪随机，每次操作每个点的概率是 $\frac{1}{n}$。考虑这样一种做法，维护 $\min$ 值，当修改的点是 $\min$ 时暴力扫一遍，由于期望下每 $n$ 次才会修改到 $\min$ 一次，于是期望复杂度 $O(m)$。

**string**

编辑距离的变种，题目的特殊约束说明不存在连续的交换操作，仍然可以用 DP 求解。

**sequence**

对每个点维护 $pre$ 表示其上一个颜色相同的位置，那么一次询问相当于求 $\sum_{i=l}^r [pre(i) < l]$。  

修改操作为区间覆盖，考虑颜色段均摊，每次最多增加 $2$ 个颜色段，总段数是 $O(n+m)$ 级，每次删去被新段完全覆盖的段，每段最多删一次，总共删除次数也是 $O(n+m)$ 的。用 set 维护所有段。此外，$pre$ 的变化与增加的段数是正相关的，因此 $pre$ 的变化也是 $O(n+m)$ 级别的。可以都当作单点修改。结合上面的询问就是三维偏序，用 CDQ 分治求解，复杂度 $O(n \log^2 n)$。

## 2021/12/18

**score**

邻项交换可得最优的策略是按 $\frac{a_i}{t_i}$ 降序解题，对于每一个 $\frac{a_i}{t_i}$ 相等的段，可以求出每道题的最早时间和最晚时间。  
由于答案具有单调性，可以二分，然后按 $a_i$ 从小到大扫，如有逆序对则不合法。复杂度 $O(n \log n)$

**travel**

发现最优路线在 $x, y$ 上总有一维是单调的。假设 $x$ 维是单调的，于是只需维护 $y$ 维上的最短路线。用 set 维护路线，从左到右扫每个矩形，取出 set 中被该矩形挡住的所有路线，更新最优的两条分别往上/下走，删掉其余的路线。摊还分析复杂度是 $O(n \log n)$ 的。

## 2021/12/20

**交友**

建立最小割模型，每个点 $v_i$ 连 $(v_i, T, lim)$, 每条边 $e_i$ 连 $(S, e_i, 1)$, 假设其连接端点为 $x, y$，连 $(e_i, x, \infty)$ 与 $(e_i, y, \infty)$。  
割 $e_i$ 表示不选此边，割 $v_i$ 表示选该点。最小割 $mincut = \min \{ m - |e(s)| + lim|s| \} = m + \min \{ lim|s| - |e(s)| \}$。

考虑所求为 $\max \{ |e(s)| - lim|s| \} + lim = m - mincut + lim$。

但由于直接流可能一个点也不选，因此需要枚举每个点，钦定选择该点。具体操作是先退回流经点的流量，然后将该点与 $T$ 连边容量设为 $0$，再从源点增广退回的流量。由于边容量 $\leq lim$，总复杂度看作是 $O(n(n+m) lim)$。

**弱化的杨表**

将题意转化为在一个长 $2n$ 的序列中放 $n$ 个左括号和 $n$ 个右括号，每个位置作为左括号的代价为 $a$，右括号的代价为 $b$。求最小代价。

带悔贪心的思想，不断维护前 $2i$ 个括号的合法序列，用增量法考虑添加两个新的相邻位置 $x, y(y=x+1)$。首先可以在 $x, y$ 处都放右括号。此时必须从前 $2i$ 个括号中找到一个右括号将其变成左括号，这样就能腾出两个左括号（一个是由右括号变来的，一个是和右括号原来匹配的），与 $x, y$ 匹配即可。正确性自证。  
贪心地，每次一定会找 $a-b$ 最小的右括号变左括号。用堆维护所有右括号和他的转化代价即可。

## 2021/12/21

**treasure**

考虑每个点 $x$ 的期望贡献，当且仅当根到 $x$ 的路径依次访问，即有 $dep (x)$ 个点必须维持相对顺序。考虑在 $n$ 个位置中任取 $dep (x)$ 个位置，这 $dep (x)$ 个点填进去共有 $dep (x)!$ 种顺序，但 $x$ 有贡献的只有一种，即 $x$  的期望贡献为 $\frac{1}{dep(x)!}$。另外注意特判环上点。

**footprint**

发现最优的方案中不存在连续的回头，即方案是由若干条往前走的链首尾拼接起来。由此可求得答案下界，即为最小链覆盖。  
进行完链覆盖后得到了一堆链，将其分类为 LL、LR、RL、RR 表示首尾的字符。考虑能否构造出一个合法方案，若合法显然最优。  

由于 LL 和 RR 的数量差不大于 $1$（大于 $1$ 时 L 和 R 数量差大于 $1$，不符题意）。可以先把 LL 和 RR 合并，最后只有可能得到 LL 或 RR 或 LR。  
然后把所有 LR 合并成一个大LR，所有 RL 合并成一个大RL，把 大LR 或 大RL 靠后的末尾接到对面的末尾，得到一个 LL 和 RR，合并成 LR。然后与上面得到的 LL 或 RR 合并即得到答案。

**points**

一个引理：$a^2 \equiv a \pmod 2$

两个点冲突当且仅当 ${\Delta x}^2 + {\Delta y}^2 = D$，由上述引理可得 ${\Delta x} + {\Delta y} \equiv D \pmod 2$。

可以预先将所有点奇偶染色。  
* 如果 $D$ 是奇数，那么冲突只会在异色点之间。
* 否则，冲突只会在同色点之间。把所有同色点（仅考虑奇色）拿出来，斜 $45 \degree$ 看，相当于是一个菱形。把这个菱形建一个新坐标系，单位长度是原坐标系的 $\sqrt{2}$ 倍。并且在新坐标系中 $D \to \frac{D}{2}$。进一步的，如果连续两次旋转，又会转正，此时原坐标系中的点坐标 $(x, y) \to (\frac{x}{2}, \frac{y}{2})$（画图体会）。  

综上，做法如下：

不断将 $D$ 除以 $4$，设 其含 $4$ 因子 $k$ 个。  
最后，若 $D$ 为奇数，相当于将所有点按 $\lfloor \frac x{2^k}\rfloor + \lfloor \frac y{2^k}\rfloor$ 奇偶分类，否则按 $\lfloor \frac x{2^k}\rfloor$ 奇偶分类。一共有两个 $D$，把所有点分成了四类，选最多的一类即可。（由鸽巢原理可知一定存在解）

## 2021/12/23

**travel**

要特别注意到点权一定为正。

几个性质：

> 一定存在最优方案至少经过一个叶节点，且起点是叶结点。

证明：
* 对于一个方案，如果不经过叶节点，那么结尾点一定能往下走到一个未被经过的叶节点，答案变大。
* 如果一个方案起点 $x$ 不是叶节点，那么把起点设为 $x$ 子树中叶节点一定不劣。

> 一定存在最优方案，每次往祖先走只会走深度最大的未访问点。

证明：

假设当前点深度最大的未访问祖先为 $x$，深度较小的为 $y$。如果走 $y$ 而不走 $x$，分情况讨论：
* 如果以后会访问 $x$ 子树点，那么不如一开始先走 $x$，然后访问子树点，最后走到 $y$，不劣。
* 如果以后不会访问 $x$ 子树点，那么先走 $x$ 再走 $y$ 相较于原方案多了 $x$ 的贡献，更优。

根据上面两个性质，可以确定大致的维护顺序：从下往上。

考虑次下层点 $x$，其所有儿子均为叶结点。如果起点在 $x$ 儿子中，一定选择点权最大的点 $A_{\max}$ 出发，然后向上走到 $x$，再向下走到次大点 $A_{\sec}$。可以把此三者缩成一个大点 $A_{new} = A_x + A_{\max} + A_{\sec}$。把 $A_{new}$ 和 $x$ 的其他儿子放到一起考虑，他们相当于一个新的点集，走了其中一个后就必须向上走 $x$ 的祖先（因为 $x$ 被包含在 $A_{new}$ 中），可以理解成把这些点挂到 $fa_x$ 上去，把这些点看作新一轮的叶节点， $fa_x$ 则变成了次下层点。

用 $set$ 维护所有点，点数 $O(n)$ 级，要支持合并两个点集，用启发式合并，复杂度 $O(n \log^2 n)$。

## 2021/12/24

**background**

分析 $a$ 序列中的性质，考察 $a$ 序列中的所有 $x$ 位数 $\overline{p_1p_2\dots p_x}$，如果不考虑个位，把剩下的 $x-1$ 位看作是 $x-1$ 位数 $\overline{p_1p_2\dots p_{x-1}}$，那么这个数是可以取遍所有 $x-1$ 位数的。  
原因在于每次加的 $\operatorname{maxdigit}$ 是 $[0, 10)$ 的整数，导致每次个位**最多**进位一次，相当于前 $x-1$ 位构成的 $x-1$ 位数每次最多加一。又由于序列 $a$ 首项是 $1$，因此所有 $x-1$ 位数都能遍历到。

由上面的分析可以想到判定一个数是否属于序列 $a$ 的方法。  
设状态 $f (x, y)$，表示 $a$ 序列中是否存在一个数 $\overline{p_1p_2\dots p_n}$ 满足 $x = \overline{p_1p_2\dots p_{n-1}}$ 且 $y = p_n$，若存在则为真，否则为假。转移显然。  
但这个东西还是没什么用。考虑优化，每次操作会加上 $\operatorname{maxdigit}$，如果从高位往低位地确定每一位，假设现在到了第 $i$ 位，其实并不关心更高位的具体取值，只要知道更高位的 $\operatorname{maxdigit}$ 记为 $vx$ 即可。还需要知道此时个位 $vf$。于是可以设状态 $f (vx, i, vi, vf)$ 表示当前考虑到第 $i$ 位，更高位 $\operatorname{maxdigit} = vx$，个位为 $vf$，第 $i$ 位 $0 \to vi$ 后个位会变成什么。转移也不难实现，同时维护一个状态 $nxt (vx, i, vf)$，变量意义同上，表示要让第 $i+1$ 位 $+1$ 后个位的新取值。

有了上面的状态，就能在 $O(|\texttt{位数}|)$ 的时间内判断一个数是否属于序列 $a$。解决了判定问题，想要计数也不是难事，设 $dp (p, vx, i, vf)$ 表示当前在 $p$ 点，填到第 $i$ 位，该怎么来就怎么来。

## 2021/12/25

**骨灰**

乱搞，复杂度分析

**智子**

打表 $\mathrm{SG}$ 函数，找规律。

**墓地**

根据版本之间的继承关系可以建出一个树形结构，称之为版本树（根为 $0$）。  
版本树上每个点代表的版本的正确物品，为执行完根到该点路径上所有操作后的物品，而每个操作（视为删除一个物品并添加一个新物品）只会影响一个子树。  
自然想到对版本树的 DFS 序维护线段树分治，树上每个点只会在进入时执行一次操作，并在回溯时撤回操作，产生的区间总数是 $O(n+q)$ 的。加入物品时用单调队列优化多重背包，总复杂度 $O((n+q)m \log q)$

## 2021/12/28

**计树**

考虑每个置换环，可以通过手玩或分析得到几个性质：

1. 环长 $>2$ 的环内不能有边。
2. 两长为 $n, m(n < m)$ 的环能相连必须满足 $n \mid m$。
3. 任意环长为 $n$ 的环只能与至多一个环长 $<n$ 的环相连。
4. 两环相连的方案数有 $\gcd (n, m)$ 种。

不难想到按环长从小到大处理，维护一棵树（根环长 $\leq 2$）并不断加入新环。对于一堆环长相等的环（设环长为 $n$）一起处理，找到树上所有能连的祖先点（即为 $n$ 的因数），这些环如果连树上点 $m(m \mid n)$，那么贡献是 $m$，内部连边贡献是 $n$。枚举与树上点的连边树然后 prufer 序列统计答案。

**先辈的游戏**

考虑每个联通块长啥样。发现一定是一个 $\rho$ 型。由于存在优先级的问题，环长最多为 $2$。因此二元环的个数就是连通块的数量。考虑每个二元环的期望贡献即可。

## 2021/12/31

**B 君的递回**

把递推关系写成线性变换形式，十进制矩阵快速幂即可。

**B 君的期望**

FWT 分类讨论。

**B 君的交错**

LGV 引理模板题。

## 2022/01/01

**猜数游戏**

区间 DP，两个要求分别做一遍即可。

## 2022/01/04

**清理通道**

把随从看作是二维平面上的点 $(w_i, s_i)$，那么每个跟班能解决一个 $x$ 方向或 $y$ 方向的半平面。贪心地考虑，对于一个 $x$ 跟班 $j$（只能解决 $w_i < x_j$ 的随从 $i$），一定尽量解决能解决的随从中 $s_i$ 大的，给 $y$ 跟班更优的决策空间，而 $x$ 跟班内部肯定是按 $x_j$ 升序考虑。二分最小时间，用数据结构维护上面过程。

**砰砰博士**

性质：

1. 若 $a, b$ 同色且 $a < b$，那么不存在连线 $(a, c), (b, d)$ 有 $c > d$。
2. 考虑任意位置，考虑跨过该处的所有连线，必然是一边全为红另一边全为蓝。
3. 若把所有连续的相同颜色缩成一段，那么连线只会在相邻两段中。

相当于每个段都会划分成两部分，前一部分向左连边，后一部分向右连边，两段之间的连线可以简单推出。用 DP 实现这一过程。

**怪盗之翼**

转化问题，铺轨道相当于连两条边：

1. 均为上下方向或均为左右方向则为直道。
2. 两条边方向不同则为弯道。

根据题意，只有第二种情况才有贡献。  
此外，对网格图进行黑白奇偶染色后连边只在异色点中存在。一个铺轨道的方案合法当且仅当每个合法点的度数均为 $2$。  

考虑网络流，建模如下：  
> 每个点 $i$，拆成 $i_1, i_2, i_3$：$i_1$ 表示点本身，$i_2$ 表示上下连边，$i_3$ 表示左右连边。  
> $(u, v, c, w)$ 表示连一条 $u$ 到 $v$ 的容量为 $c$ 费用为 $w$ 的边。  
> $s$ 为源点， $t$ 为汇点。
* 对于白点 $j$，连 $(s, j_1, 2, 0), (j_1, j_2, 1, 0), (j_1, j_2, 1, w_j), (j_1, j_3, 1, 0), (j_1, j_3, 1, w_j)$
* 对于黑点 $k$，连 $(k_1, t, 2, 0), (k_2, k_1, 1, 0), (k_2, k_1, 1, w_k), (k_3, k_1, 1, 0), (k_3, k_1, 1, w_k)$
* 对于相邻两点 $j, k$（假设 $j$ 白 $k$ 黑），若 $j, k$ 位于左右方向，连 $(j_3, k_3, 1, 0)$，否则连 $(j_2, k_2, 1, 0)$

答案为 $\sum_i w_i - mincost$（流不满则无解）  
正确性感性理解一下，如果一个点 $i$ 为直道即两次流经 $i_2$ 或 $i_3$，那么费用为 $w_i$，减掉后说明 $i$ 没贡献。否则 $i_2$ 和 $i_3$ 各流一次，由于是最小费用最大流，肯定都走费用为 $0$ 边，相当于 $i$ 有 $w_i$ 的贡献。符合要求。

## 2022/01/05

**序列**

把 $a_i$ 定为所有 $i$ 连边的边权的 $\operatorname {lcm} (\forall v(e_i))$ 是最优的。  
考虑什么时候会不合法，$\gcd (a_i, a_j) \not= c$ 当且仅当存在 $e_i, e_j$ 满足 $\gcd (v(e_i), v(e_j)) \nmid c$，即 $v(e_i), v(e_j)$ 存在共同因子是 $c$ 的倍数或者有 $c$ 不含的质因子。

直接枚举的上界是 $(\sum \deg (i))^2$ 即 $O(m^2)$，可以通过。

**操作**

等价于选择一个美的序列 $b$，最小化 $\sum |a_i-b_i|$。

$b$ 可以有 $b_0, b_1$ 唯一确定，并且简单操作后可以视作 $3$ 个一循环，要求：

$$
\sum_{i \equiv 0 \pmod 3} |a_i-b_0|+\sum_{i \equiv 1 \pmod 3} |a_i-b_1|+\sum_{i \equiv 2 \pmod 3} |a_i-(b_1-b_0)|
$$

一个结论是答案关于 $b_0$ 单峰。于是可以三分 $b_0$，$\sum_{i \equiv 2 \pmod 3} |a_i-(b_1-b_0)|$ 这一坨相当于求一个新数组 $c_i = a_i + b_0$ 的 $\sum_{i \equiv 2 \pmod 3} |c_i-b_1|$，整合起来就是要最小化这个：

$$
\sum_{i \equiv 1 \pmod 3} |a_i-b_1|+\sum_{i \equiv 2 \pmod 3} |c_i-b_1|
$$

根据经典的结论可知最优的 $b_1$ 是 将 $a_i, c_i$ 有序化后的中位数。题目的特殊性质保证了 $a, c$ 的有序，问题转化为快速求两个有序数组的中位数即第 $\lfloor \frac{n+1}{2} \rfloor$ 大。做法是不断比较 $a_{n/2}$ 和 $b_{n/2}$ ，不断砍掉区间，参考 [元旦激光炮](https://uoj.ac/contest/6/problem/52)。

## 2022/01/07

**取石子**

假设 $a \leq b$，分别考虑每一堆石子 $x_i$：  

令 $r \gets x_i \bmod (a+b)$。  

* $r < a$：先手必败
* $r \geq b$：先手必胜
* $a \leq r < b$：A 必胜

特别地，满足 $2a \leq r < b$ 的石堆标为特殊堆。

手玩过后发现包含两个特殊石堆 A 必胜，奇数个先手必胜石堆则先手必胜，否则后手必胜。当包含一个特殊石堆且偶数个先手必胜石堆，则 A 必胜。

**字符串**

首先肯定往 AC 自动机方面考虑。  
考虑每个串，考虑其是否跨过中间部分，如果不横跨，那么要么正串在前半部分出现过，要么反串（正串翻转并取反）出现过。如果横跨，简单判断一下，要么正串的一个前缀是前半部分的后缀，要么正串的一个后缀的反串是前半部分的后缀。  
在自动机上 DP，累计答案的时候把包含串的集合并上后缀所在状态的包含哪些串的前缀之类的。

**树**

简单的转化：不包含 $m$ 连树 $\iff$ 任何一条根到叶子的路径使得往左儿子走的次数 $< m-1$。  

考虑如何构造并遍历一颗满二叉树，增量法，一开始只有一个结点。  
每一步的决策：  
* 做为叶子，退回到父亲。
* 新建一个左儿子，转到左儿子；
* 如果已存在左儿子，新建一个右儿子，转到右儿子；
* 如果已存在右儿子，退回到父亲。

根据这个构造方案，每个满二叉树都对应了一个操作序列。如果把新建左儿子视作 $+1$, 新建右儿子视作 $-1$，那么相当于序列的任意前缀和 $<m - 1$。  

这个问题可以进一步转化为一个点只能向右上或向右下走，不能穿过两平行直线走到某点的方案数，用翻折法容斥解决。

## 2022/02/07

**希望之树**

点集直径的经典结论：两个点集 $S_1, S_2$，$S_1$ 直径为 $(u_1, v_1)$，$S_2$ 直径为 $(u_2, v_2)$，则 $S_1 \cup S_2$ 的直径可由四点两两组合得到。

每次询问均为一段连续区间，用线段树预处理即可。时间复杂度 $O(n \log^2 n)$。

**斗主地**

题目要求即为 $n$ = 逆序对数 + 置换环数。

考虑增量法，从大到小把数插入序列，每次 $n$ 加一，逆序对数 + 置换环数至少加一。要保证合法须要么逆序对数加一，要么置换环数加一。DP 维护即可。

## 2022/02/08

**鸽子**

把每个点的入点出点各拆成两点共四个点。相当于求一个二分图的合法连边数。

考虑二维容斥，枚举违反自环数、重边数，DP 计算出 $f (i, j)$ 表示 $i$ 组限制两次，$j$ 组无限制的方案数。

## 2022/02/11

**三元组**

题目只要求三元组的存在性，点 $i$ 为中心的三元组存在当且仅当，仅考虑 $[1, i)$ 的位置，值域上以点 $i$ 为中心的值域字符串（$x$ 出现则 $x$ 处为 $1$，否则为 $0$）非回文串。  
从左往右扫整个序列，用两个树状数组分别维护值域字符串及反串的 Hash 值就能快速判断回文。

**山水画**

本质不同的条件很奇怪，从这里入手。相当于枚举每个数字的出现次数，统计多少种出现次数能构造出一个合法的方案。手玩发现如果方案合法一定能构造出 $\texttt{12121232323234343...}$ 模式的方案，特殊考虑末尾可能是 $mx$ 或 $mx - 1$。组合数化简即可。

## 2022/02/12

**项链**

首先，项链可以由红色珠子分割成若干子段且互相独立。考虑每一个子段，枚举第一次删哪条边，就被分成两部分，形如 x-o-o-o-o（x 为红珠，o 为白珠），从左往右顺序编号，边 $i$ 能删当且仅当 $[1, i - 1]$ 在 $i$ 后面，期望为 $\dfrac{1}{i}$。整理一下式子就能简单计算。

**数正方体**

通过一一对应可以转化为统计把 $a, b$ 都排序后满足条件的积木正方体个数。

考虑限制为 $min$ 的所有位置，构成了一个 L 形。L 形内部做容斥满足限制，而内部不会达到外面的限制，外面仍是一个矩形，递归处理。

## 2022/02/14

**endemic**

仅考虑差分数组，每次可以选定两点 $x, y$，执行操作 `d[x]--, d[y]--`。要求使得 $d_i \geq 0(2 \leq i \leq n)$。  
总值是守恒的，差分数组一个位置变大一定存在另一位置相应地变小。要让 $d_i < 0$ 的所有 $d_i$ 变大，相应地要选取一些 $d_i > 0$ 的 $i$ 和 $1, n+1$ 来“供能”。考虑费用流，由源点向 $d_i > 0$ 的 $i$ 和 $1, n+1$ 连边，流量为 $d_i$（$1, n+1$ 为无穷），所有 $d_i < 0$ 的 $i$ 向汇点连边，流量为 $-d_i$。对于每个操作，连上所有可以执行它的点对 $(u, v)$，保证 `d[u]--, d[v]++`。  
这样连边后，一条从源点到汇点的增广路就相当于 $d_i > 0$ 的位置向 $d_i < 0$ 的位置供能一次。跑最小费用最大流，若跑不满说明无解，否则最小费用即为答案。

**epidemic**

线段树维护标记，$\texttt{+/+/+/+/...}$ 每个 $\texttt{+/}$ 分为一组，感性理解，只需保留末尾的 $30$ 左右组即可，因为更久的会被除到没有贡献。

**pandemic**

答案下界为 $\lceil \dfrac{l}2 \rceil$，其中 $l$ 为直径长度。并且能够构造出下界方案。因此只需计数时刻最大不开心值 $\leq \lceil \dfrac{l}2 \rceil$ 的方案即可。设 $f (i, j, k)$ 表示考虑到 $i$ 点及其子树，向下的最大值为 $j$，向上的最大值为 $k$，简单子树合并可做到 $O(n^5)$，借助图像分析 + 前缀和优化可至 $O(n^3)$。

## 2022/02/15

**simple**

将代价差分，从大到小枚举 $a_i$，设状态 $f (i, j, k)$ 表示已处理完 $[1, i]$，有 $j$ 个组未闭合，当前总代价为 $k$。  
转移考虑第 $i+1$ 个数的方案：

* 自成一组
* 作为新的一组的 $\max$
* 作为前 $j$ 组某组的 $\min$
* 作为前 $j$ 组值域中间一值

第一维滚动处理可优化空间，时间复杂度 $O(n^2k)$。

**s2mple**

结论：无向图中树的数量 = 将所有边定向后最少的入度为零点。

证明：  
考虑每个无向图每个连通块，分类讨论：

* 连通块为树，任选一点为根，所有边定向为外向生成树。则只有根入度为 $0$。
* 连通块不为树，先提出一颗生成树，任选一个连有返祖边的点为根，定向为外向生成树，然后返祖边指向根，就能使得所有点入度均非零。

综上可知结论成立。

问题转化为将边定向后最小化入度为零点即最大化入度非零点，每个点集选一条边并定向等价于任选一点使其入度加一。建立二分图网络流模型，每个点集各建一点，源点向所有代表点集点连边，所有代表点向点集内点连边，所有原图中点向汇点连边，容量均为 $1$，最大流即为最多的入度非零点。

**s3mple**

题目要求最小的链覆盖次数覆盖所有边，Dilworth 定理转化为求最长反链。由于给出的图为平面上的 DAG，转对偶图后最长反链即为最长路。

此题中的转法：

* 找到入度为 $0$ 点（有且仅有一个），从该点 DFS 找出所有点**入边**的顺序（自西向东），出边顺序在输入中已给定。
* 进行拓扑排序，每次只解决当前点所有出边之间所夹面之间的连边。直接自西向东依次连即可。特殊注意最左、最右的面已存在的情况，直接继承编号。