## 记录

**Lemon**

首先发现最重要的性质：

> 柠檬形成一个大根堆。

证明：

任意点对 $(x, y)$，其中 $y$ 为 $x$ 父亲。若 $w_x > w_y$，则交换 $w_x, w_y$ 必然不劣于不交换，进行完所有交换操作后，任意父亲 $w$ 不小于儿子 $w$。

先考虑无加固操作情况，由这个性质得到一个朴素做法，建立一个大根堆，维护所有能操作的点集，从大到小放柠檬 $q$，每次取出点集中 $d$ 最大的点 $p$，将柠檬 $q$放到 $p$ 处，弹出 $p$ 并将 $p$ 所有儿子入堆。如果存在某一时刻 $w_q > d_p$，则无解。

有加固操作，在于当第一次遇到 $w_q > d_p$ 时，需要进行加固。无法立刻得出具体加固哪个点，但肯定加固当前在堆中的某个点。

引入一个判定的方法，记 $s_i = \min \{ s_{fa}, d_i \}$，特别有 $s_1 = d_1$。那么 柠檬 $j$ 能放在结点 $i$ 当且仅当 $w_j \leq s_i$。然后一定 $s, w$ 大配大，小配小，把 $s, w$ 看作是值域数轴上的一些 $+1(s), -1(w)$，当且仅当任意位置 $S_+ \geq S_-$，即对于每个 $w_j$，比它大的 $s_i$ 数量记作 $c_j$，需满足 $c_i \geq i$。维护全局 $c_i - i$ 最小值即可。

回头看到可能加固的所有点，实际上可以枚举加固哪一个，然后遍历其子树更新 $s$，并进行判定，最后还原。由于堆中点的子树互不相交，总时间复杂度 $O(n \log n)$。

**Triplet**

发现可以通过询问 $5$ 个元素中所有三元组确定每个元素。然后任选其中三元素，设为 $a, b, c(a < b < c)$。

考虑确定其他元素（设为 $x$），如果 $x < a$ 或 $x > b$，可以通过一次查询 $(a, b, x)$ 求得。否则再查询 $(b, c, x)$。一个优化是当 $a < x < b$ 时用 $x$ 去更新 $a$ 或 $b$，使得 $[a, b]$ 长度减半。这样复杂度是 $O(n + \log V)$。