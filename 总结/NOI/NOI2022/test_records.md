[TOC]

## 2022/5/10

### 或

不同的 $2$ 的次幂模 $3$ 结果只可能为 $1, 2$。  
考虑容斥，强制一些位置只能为 $0$，其他位置任意。DP 计数满足条件的 $3$ 的倍数。

### 走

* 这里位置编号为 $[0, n - 1]$。

朴素的状压 DP 状态数过多。  
考虑优化状态数：  
* 不关心位置标号，只关心已经走过的位置和当前位置的相对关系。因此可以把当前的位置按死在 $0$，每次移动时把走过的位置相对移动。这样做还有个好处是可以把环当成链来考虑。
* 现在 $0$ 为当前位置。如果 $[1, n - 1]$ 中存在两对 $11$，那么这两对 $11$ 中间的位置一定无法经过，全都视为经过即可。
* 由于是环，并且向左向右的操作一样，只保留 $[1, n - 1]$ 比翻转后的字典序小的状态。

统计答案：  
$E  =\sum len \times p$，遍历每一个终止状态，$len$ 为长度，$p$ 为概率。终止状态不好记录，把 $p$ 拆成 $len$ 份在路径上所有非终点处贡献。每个非终止状态的贡献为 $\sum p_{leaf} = p$。同时也省去了记录 $len$。

### 机

提答题，用位运算实现若干操作。

## 2022/5/12

### 罗契

特殊限制保证了不会走要塞内部边，因此每个要塞只有被包含和不被包含两种状态，可以任取要塞上一格作为代表元。  

判断点在多边形内部采用射线法，为了方便，统一射线向上。  
BFS 遍历，维护 $f (x, y, st, dc)$ 分别表示当前的位置 $(x, y)$，每个要塞代表元所引射线经过当前路径边数的奇偶，当前经过的危险边数。


### 暴政之王

一个排列可以分解为若干置换环。一个大小为 $x$ 的置换环置换 $m$ 次会被分解成 $gcd (x, m)$ 个大小相同的小置换环。  
倒着考虑，最终序列的置换环能合并出多少种不同的置换环集合。独立考虑合并每种大小的置换环，假设当前考虑到大小为 $l$ 的置换环，共 $c$ 个，有 $k$ 个合法的合并数量 $b_1, \dots, b_k$。写成 EGF 的封闭形式为：

$$
F(x)=\sum_{i=1}^k x^{b_i} \frac{l^{b_i-1}}{b_i} \\
G = e^F
$$

所求即为 $[x^c]G$。进行如下推导：

$$
G=e^F\\
G' = F'e^F\\
G'=F'G\\
\int G' = \int F'G\\
G = \int F'G\\
\left[ x^n\right]G = \frac{1}{n}\left[x^{n-1}\right]GF'\\
$$

求出 $F'$ 的具体系数，暴力卷出 $G$ 即可。  
复杂度 $O(n d(m))$。

## 2022/5/14

### 加边

每个操作可以视作一个三元组 $(t_i, e_i, i)$，影响一个查询 $(t_i = 1, e_i, i)$ 的激活操作需要满足 $(t_j = 2, e_j \leq e_i, j < i)$。回答一个查询可以把所有对其有影响的激活操作扔到序列上进行若干区间取 $max$，然后查询全局 $min$。

考虑对操作序列 $[1, q]$ 分块：  
对于每个块 $[l, r]$，顺序遍历额外边序列 $[1, m]$，若当前边 $x$ 的激活时间 $<l$（即存在 $(t_j = 1, e_j = x, j < l)$），则进行它的影响；然后遍历所有 $(t_i = 2, e_i = x, i \in [l, r])$，把尚未加入的影响 $(t_j = 1, e_j \leq x, j \in [l, i))$ 加入后查询，接着回滚掉这一部分影响。

用树剖维护影响，设块长为 $s$，复杂度为 $O(\dfrac{q}{s} m\log^2 n + qs \log^2 n)$，理论上 $s = \sqrt{m}$ 最优，此时复杂度为 $O(q\sqrt {m}\log^2 n)$。

### 嘉然

理性推导可得 $\varphi (ab) = \dfrac{\varphi(a)\varphi(b)\gcd(a, b)}{\varphi(\gcd (a, b))}$。  
根据上式，一个暴力的做法：对于每个询问，枚举 $d$，找到 $\gcd (a, b) = d$ 的 $\varphi (a)\varphi(b)$ 最大值。发现可以弱化限制，只需满足 $d \mid \gcd (a, b)$ 即可，因为错误计算出的答案一定比正确答案小。因为 $p$ 是排列，所有 $d$ 的倍数数量之和为 $O(n \ln n)$，因此这个做法的复杂度是 $O(qn \ln n)$。

考虑优化。对于一个 $d$，有可能作为答案的点对数量并不多：考虑作为点对 $(i, j)$ 中 $\varphi$ 较小的 $i$，包含 $i$ 的可能作为答案的点对只有两个，一个是 $i$ 和 $i$ 前面第一个 $\geq \varphi (p_i)$ 的 $j$，另一个是后面第一个。因为除了这两个点对，其他的都能被一个作用域更小，答案更优的点对替代。

找出上面所有的点对，抽象为三元组 $(x, y, v)$。每个询问 $(l, r)$ 相当于要求 $l \leq x < y \leq r$ 的 $\max \{ v \}$，双指针 + BIT 处理。