[TOC]

## 2022/5/10

### 或

不同的 $2$ 的次幂模 $3$ 结果只可能为 $1, 2$。  
考虑容斥，强制一些位置只能为 $0$，其他位置任意。DP 计数满足条件的 $3$ 的倍数。

### 走

* 这里位置编号为 $[0, n - 1]$。

朴素的状压 DP 状态数过多。  
考虑优化状态数：  
* 不关心位置标号，只关心已经走过的位置和当前位置的相对关系。因此可以把当前的位置按死在 $0$，每次移动时把走过的位置相对移动。这样做还有个好处是可以把环当成链来考虑。
* 现在 $0$ 为当前位置。如果 $[1, n - 1]$ 中存在两对 $11$，那么这两对 $11$ 中间的位置一定无法经过，全都视为经过即可。
* 由于是环，并且向左向右的操作一样，只保留 $[1, n - 1]$ 比翻转后的字典序小的状态。

统计答案：  
$E  =\sum len \times p$，遍历每一个终止状态，$len$ 为长度，$p$ 为概率。终止状态不好记录，把 $p$ 拆成 $len$ 份在路径上所有非终点处贡献。每个非终止状态的贡献为 $\sum p_{leaf} = p$。同时也省去了记录 $len$。

### 机

提答题，用位运算实现若干操作。

## 2022/5/12

### 罗契

特殊限制保证了不会走要塞内部边，因此每个要塞只有被包含和不被包含两种状态，可以任取要塞上一格作为代表元。  

判断点在多边形内部采用射线法，为了方便，统一射线向上。  
BFS 遍历，维护 $f (x, y, st, dc)$ 分别表示当前的位置 $(x, y)$，每个要塞代表元所引射线经过当前路径边数的奇偶，当前经过的危险边数。


### 暴政之王

一个排列可以分解为若干置换环。一个大小为 $x$ 的置换环置换 $m$ 次会被分解成 $gcd (x, m)$ 个大小相同的小置换环。  
倒着考虑，最终序列的置换环能合并出多少种不同的置换环集合。独立考虑合并每种大小的置换环，假设当前考虑到大小为 $l$ 的置换环，共 $c$ 个，有 $k$ 个合法的合并数量 $b_1, \dots, b_k$。写成 EGF 的封闭形式为：

$$
F(x)=\sum_{i=1}^k x^{b_i} \frac{l^{b_i-1}}{b_i} \\
G = e^F
$$

所求即为 $[x^c]G$。进行如下推导：

$$
G=e^F\\
G' = F'e^F\\
G'=F'G\\
\int G' = \int F'G\\
G = \int F'G\\
\left[ x^n\right]G = \frac{1}{n}\left[x^{n-1}\right]GF'\\
$$

求出 $F'$ 的具体系数，暴力卷出 $G$ 即可。  
复杂度 $O(n d(m))$。

## 2022/5/14

### 加边

每个操作可以视作一个三元组 $(t_i, e_i, i)$，影响一个查询 $(t_i = 1, e_i, i)$ 的激活操作需要满足 $(t_j = 2, e_j \leq e_i, j < i)$。回答一个查询可以把所有对其有影响的激活操作扔到序列上进行若干区间取 $max$，然后查询全局 $min$。

考虑对操作序列 $[1, q]$ 分块：  
对于每个块 $[l, r]$，顺序遍历额外边序列 $[1, m]$，若当前边 $x$ 的激活时间 $<l$（即存在 $(t_j = 1, e_j = x, j < l)$），则进行它的影响；然后遍历所有 $(t_i = 2, e_i = x, i \in [l, r])$，把尚未加入的影响 $(t_j = 1, e_j \leq x, j \in [l, i))$ 加入后查询，接着回滚掉这一部分影响。

用树剖维护影响，设块长为 $s$，复杂度为 $O(\dfrac{q}{s} m\log^2 n + qs \log^2 n)$，理论上 $s = \sqrt{m}$ 最优，此时复杂度为 $O(q\sqrt {m}\log^2 n)$。

### 嘉然

理性推导可得 $\varphi (ab) = \dfrac{\varphi(a)\varphi(b)\gcd(a, b)}{\varphi(\gcd (a, b))}$。  
根据上式，一个暴力的做法：对于每个询问，枚举 $d$，找到 $\gcd (a, b) = d$ 的 $\varphi (a)\varphi(b)$ 最大值。发现可以弱化限制，只需满足 $d \mid \gcd (a, b)$ 即可，因为错误计算出的答案一定比正确答案小。因为 $p$ 是排列，所有 $d$ 的倍数数量之和为 $O(n \ln n)$，因此这个做法的复杂度是 $O(qn \ln n)$。

考虑优化。对于一个 $d$，有可能作为答案的点对数量并不多：考虑作为点对 $(i, j)$ 中 $\varphi$ 较小的 $i$，包含 $i$ 的可能作为答案的点对只有两个，一个是 $i$ 和 $i$ 前面第一个 $\geq \varphi (p_i)$ 的 $j$，另一个是后面第一个。因为除了这两个点对，其他的都能被一个作用域更小，答案更优的点对替代。

找出上面所有的点对，抽象为三元组 $(x, y, v)$。每个询问 $(l, r)$ 相当于要求 $l \leq x < y \leq r$ 的 $\max \{ v \}$，双指针 + BIT 处理。

## 2022/5/17

### 逃离藏宝洞

首先不难发现一个朴素的做法：走两次并询问两次找到第一步，然后剩下 $n-1$ 步每一步走一次并询问一次，结合上一步的信息找到下一步。
上述做法能解决 $lm, lq \geq n + 1$ 的情况。观察到最后几组数据满足 $lq < n < lm$，提示我们要多走少问。  
首先还是暴力找到第一步，当前状态可以用 $(i, lst)$ 表示，其中 $i$ 为海拔，$lst$ 为上一步的编号。考虑一次走 $x$ 步，保证相邻两步不同，那么可能走到的海拔为 $i - x + 2d(0 \leq d \leq x)$，并且其中正确步是一段前缀，长为 $d$。如果 $d < x$，可以根据已知信息走正确的 $d + 1$ 步，如果 $d = x$ 则可以恰好走 $x$ 步。这样随机地走 $d$ 步，一次询问期望能走的正确步数 $k$ 满足：

$$
k = \sum_{i=1}^d i2^{-i} + d2^{-d} = 2 - (d+2)2^{-d}
$$

可以发现，$d$ 越大时，$k$ 接近于 $2$。取 $d \geq 6$ 即可。

### 序列划分

设 $f(i)$ 表示 $[1, i]$ 所有划分的权值之和，通过枚举最后一段的长度可以得到转移方程：

$$
f (i) = \sum_{j=1}^i f_{j-1} \operatorname{mex}([j, i])
$$

考虑优化，这里采用的方法是快速维护右端点 $i$ 移动时所有左端点 $j$ 转移系数的变化。  
方便起见，记 $mex (j) = \operatorname{mex}([j, i])$。  
右端点移动一位，新增一个空集，然后所有集合新增一个元素 $a_i$，只有 $mex (j) = a_i$ 的位置发生变化。由于 $mex (j)$ 单调不增，可知 $mex (j) = a_i$ 只可能是一段连续的区间 $[l, r]$。修改这段区间的 $mex$ 会拆分成多个子区间，并且左端点 $=l$ 的子区间可能和左边相邻的一个区间合并，如果他们 $mex$ 相同。  
拆分区间 $[l, r]$ 时，先询问得到新的 $mex (r)$，拆出该 $mex$ 对应的区间 $[x, r]$，然后求解子问题 $[l, x - 1]$。求 $mex (r), x$ 的方法：维护 $lst (i)$ 表示值 $i$ 的最后出现位置，$mex (r) = min \{i\} \mid lst (i) < r$，而 $x = lst (i) + 1$，线段树维护区间 $min \{lst\}$，树上二分即可。
分析总共操作次数：初始时所有左端点 $mex = 0$，仅含一个区间；全局 $O (n)$ 个合并操作最多合并减少 $O (n)$ 个区间；任意时刻区间数最大为 $n$。综上可知，拆分操作的总数也是 $O(n)$。于是用 set 暴力维护所有 $mex$ 段，时间复杂度均摊正确，为 $O(n \log n)$。

### 重排列

根据字典序的性质，以 Alice 作为主视角贪心的确定 $R$ 的每一位。  
将限制具象化，建立图论模型，对于 $\gcd (a_i, a_j) > 1$，连边 $(i, j)$。所有点被分成若干连通子图，不同连通子图之间元素的顺序 Bob 可以任意改变，贪心的进行一个多路降序归并。  
每个连通子图相互独立，分别考虑。发现 $min$ 是一定能放到开头的，其充要条件为从 $min$ 以任意顺序遍历图（使得每个点都存在一条 $min$ 到他的路径在序列中维持相对顺序）。以 $min$ 为割点会把图划分成若干连通子图，继续递归求解。唯一的要求是这些子问题求出的序列开头一定要与 $min$ 有连边，特殊标记一下。一个优化求连通子图的方法是每个点与所有质因子相连边。  
时间复杂度 O(能过)。

## 2022/5/19

### first

用 bitset 优化找到 S 在 P 中出现的所有起始位置：  
bitset 预处理出所有小写字母 $x$ 在 P 中的位置集合 $ps(x)$，仅考虑 $S$ 中不为通配符的位置 $i$，所有 $ps (S_i) \operatorname{>>} (i-1)$ 并起来得到 S 出现的所有起始位置。  
复杂度 $O(\frac{n^2}{\omega})$。

### second

最大流 = 最小割，图是平面图，于是转化为求对偶图最短路。  
对偶图长得很特别：

```
 /- - - - -\ 
<| | | | | |>
 \- - - - -/
```

分为为两条主链，对应位置有连边。又由于边权均为正，因此最短路一定不会走回头路。可以划分成多个阶段求解并合并。每个阶段设 $f (0/1, 0/1)$ 表示边界是哪条主链，合并时格外计算有无切换主链的贡献。线段树维护即可。

### third

设 $f_i$ 表示 $1$ 到 $i$ 路径上的异色边数，有 $f_i = f_{fa_i} + [a_i \neq a_{fa_i}]$。答案即为 $\min_{\deg (i) = 1} \{ f_i \}$。

对于一次修改 $a_x \to y$，可能对三个子树中的 $f_i$ 造成 $\pm1$ 的贡献，分别是 $x$ 子树，$x$ 颜色为 $a_x$ 的儿子的子树和颜色为 $y$ 的儿子的子树。用平衡树维护 DFS 序，把颜色相同的儿子子树放到一起，每次修改就是 $O(1)$ 个区间加。改变 $a_x$ 时要同时改变 $x$ 子树在 $fa_x$ 子树中的位置，相当于 DFS 序上一次区间剪切。  
总时间复杂度 $O(n \log n)$。