[TOC]

## 2022/5/10

### 或

不同的 $2$ 的次幂模 $3$ 结果只可能为 $1, 2$。  
考虑容斥，强制一些位置只能为 $0$，其他位置任意。DP 计数满足条件的 $3$ 的倍数。

### 走

* 这里位置编号为 $[0, n - 1]$。

朴素的状压 DP 状态数过多。  
考虑优化状态数：  
* 不关心位置标号，只关心已经走过的位置和当前位置的相对关系。因此可以把当前的位置按死在 $0$，每次移动时把走过的位置相对移动。这样做还有个好处是可以把环当成链来考虑。
* 现在 $0$ 为当前位置。如果 $[1, n - 1]$ 中存在两对 $11$，那么这两对 $11$ 中间的位置一定无法经过，全都视为经过即可。
* 由于是环，并且向左向右的操作一样，只保留 $[1, n - 1]$ 比翻转后的字典序小的状态。

统计答案：  
$E  =\sum len \times p$，遍历每一个终止状态，$len$ 为长度，$p$ 为概率。终止状态不好记录，把 $p$ 拆成 $len$ 份在路径上所有非终点处贡献。每个非终止状态的贡献为 $\sum p_{leaf} = p$。同时也省去了记录 $len$。

### 机

提答题，用位运算实现若干操作。

## 2022/5/12

### 罗契

特殊限制保证了不会走要塞内部边，因此每个要塞只有被包含和不被包含两种状态，可以任取要塞上一格作为代表元。  

判断点在多边形内部采用射线法，为了方便，统一射线向上。  
BFS 遍历，维护 $f (x, y, st, dc)$ 分别表示当前的位置 $(x, y)$，每个要塞代表元所引射线经过当前路径边数的奇偶，当前经过的危险边数。


### 暴政之王

一个排列可以分解为若干置换环。一个大小为 $x$ 的置换环置换 $m$ 次会被分解成 $gcd (x, m)$ 个大小相同的小置换环。  
倒着考虑，最终序列的置换环能合并出多少种不同的置换环集合。独立考虑合并每种大小的置换环，假设当前考虑到大小为 $l$ 的置换环，共 $c$ 个，有 $k$ 个合法的合并数量 $b_1, \dots, b_k$。写成 EGF 的封闭形式为：

$$
F(x)=\sum_{i=1}^k x^{b_i} \frac{l^{b_i-1}}{b_i} \\
G = e^F
$$

所求即为 $[x^c]G$。进行如下推导：

$$
G=e^F\\
G' = F'e^F\\
G'=F'G\\
\int G' = \int F'G\\
G = \int F'G\\
\left[ x^n\right]G = \frac{1}{n}\left[x^{n-1}\right]GF'\\
$$

求出 $F'$ 的具体系数，暴力卷出 $G$ 即可。  
复杂度 $O(n d(m))$。

## 2022/5/14

### 加边

每个操作可以视作一个三元组 $(t_i, e_i, i)$，影响一个查询 $(t_i = 1, e_i, i)$ 的激活操作需要满足 $(t_j = 2, e_j \leq e_i, j < i)$。回答一个查询可以把所有对其有影响的激活操作扔到序列上进行若干区间取 $max$，然后查询全局 $min$。

考虑对操作序列 $[1, q]$ 分块：  
对于每个块 $[l, r]$，顺序遍历额外边序列 $[1, m]$，若当前边 $x$ 的激活时间 $<l$（即存在 $(t_j = 1, e_j = x, j < l)$），则进行它的影响；然后遍历所有 $(t_i = 2, e_i = x, i \in [l, r])$，把尚未加入的影响 $(t_j = 1, e_j \leq x, j \in [l, i))$ 加入后查询，接着回滚掉这一部分影响。

用树剖维护影响，设块长为 $s$，复杂度为 $O(\dfrac{q}{s} m\log^2 n + qs \log^2 n)$，理论上 $s = \sqrt{m}$ 最优，此时复杂度为 $O(q\sqrt {m}\log^2 n)$。

### 嘉然

理性推导可得 $\varphi (ab) = \dfrac{\varphi(a)\varphi(b)\gcd(a, b)}{\varphi(\gcd (a, b))}$。  
根据上式，一个暴力的做法：对于每个询问，枚举 $d$，找到 $\gcd (a, b) = d$ 的 $\varphi (a)\varphi(b)$ 最大值。发现可以弱化限制，只需满足 $d \mid \gcd (a, b)$ 即可，因为错误计算出的答案一定比正确答案小。因为 $p$ 是排列，所有 $d$ 的倍数数量之和为 $O(n \ln n)$，因此这个做法的复杂度是 $O(qn \ln n)$。

考虑优化。对于一个 $d$，有可能作为答案的点对数量并不多：考虑作为点对 $(i, j)$ 中 $\varphi$ 较小的 $i$，包含 $i$ 的可能作为答案的点对只有两个，一个是 $i$ 和 $i$ 前面第一个 $\geq \varphi (p_i)$ 的 $j$，另一个是后面第一个。因为除了这两个点对，其他的都能被一个作用域更小，答案更优的点对替代。

找出上面所有的点对，抽象为三元组 $(x, y, v)$。每个询问 $(l, r)$ 相当于要求 $l \leq x < y \leq r$ 的 $\max \{ v \}$，双指针 + BIT 处理。

## 2022/5/17

### 逃离藏宝洞

首先不难发现一个朴素的做法：走两次并询问两次找到第一步，然后剩下 $n-1$ 步每一步走一次并询问一次，结合上一步的信息找到下一步。
上述做法能解决 $lm, lq \geq n + 1$ 的情况。观察到最后几组数据满足 $lq < n < lm$，提示我们要多走少问。  
首先还是暴力找到第一步，当前状态可以用 $(i, lst)$ 表示，其中 $i$ 为海拔，$lst$ 为上一步的编号。考虑一次走 $x$ 步，保证相邻两步不同，那么可能走到的海拔为 $i - x + 2d(0 \leq d \leq x)$，并且其中正确步是一段前缀，长为 $d$。如果 $d < x$，可以根据已知信息走正确的 $d + 1$ 步，如果 $d = x$ 则可以恰好走 $x$ 步。这样随机地走 $d$ 步，一次询问期望能走的正确步数 $k$ 满足：

$$
k = \sum_{i=1}^d i2^{-i} + d2^{-d} = 2 - (d+2)2^{-d}
$$

可以发现，$d$ 越大时，$k$ 接近于 $2$。取 $d \geq 6$ 即可。

### 序列划分

设 $f(i)$ 表示 $[1, i]$ 所有划分的权值之和，通过枚举最后一段的长度可以得到转移方程：

$$
f (i) = \sum_{j=1}^i f_{j-1} \operatorname{mex}([j, i])
$$

考虑优化，这里采用的方法是快速维护右端点 $i$ 移动时所有左端点 $j$ 转移系数的变化。  
方便起见，记 $mex (j) = \operatorname{mex}([j, i])$。  
右端点移动一位，新增一个空集，然后所有集合新增一个元素 $a_i$，只有 $mex (j) = a_i$ 的位置发生变化。由于 $mex (j)$ 单调不增，可知 $mex (j) = a_i$ 只可能是一段连续的区间 $[l, r]$。修改这段区间的 $mex$ 会拆分成多个子区间，并且左端点 $=l$ 的子区间可能和左边相邻的一个区间合并，如果他们 $mex$ 相同。  
拆分区间 $[l, r]$ 时，先询问得到新的 $mex (r)$，拆出该 $mex$ 对应的区间 $[x, r]$，然后求解子问题 $[l, x - 1]$。求 $mex (r), x$ 的方法：维护 $lst (i)$ 表示值 $i$ 的最后出现位置，$mex (r) = min \{i\} \mid lst (i) < r$，而 $x = lst (i) + 1$，线段树维护区间 $min \{lst\}$，树上二分即可。
分析总共操作次数：初始时所有左端点 $mex = 0$，仅含一个区间；全局 $O (n)$ 个合并操作最多合并减少 $O (n)$ 个区间；任意时刻区间数最大为 $n$。综上可知，拆分操作的总数也是 $O(n)$。于是用 set 暴力维护所有 $mex$ 段，时间复杂度均摊正确，为 $O(n \log n)$。

### 重排列

根据字典序的性质，以 Alice 作为主视角贪心的确定 $R$ 的每一位。  
将限制具象化，建立图论模型，对于 $\gcd (a_i, a_j) > 1$，连边 $(i, j)$。所有点被分成若干连通子图，不同连通子图之间元素的顺序 Bob 可以任意改变，贪心的进行一个多路降序归并。  
每个连通子图相互独立，分别考虑。发现 $min$ 是一定能放到开头的，其充要条件为从 $min$ 以任意顺序遍历图（使得每个点都存在一条 $min$ 到他的路径在序列中维持相对顺序）。以 $min$ 为割点会把图划分成若干连通子图，继续递归求解。唯一的要求是这些子问题求出的序列开头一定要与 $min$ 有连边，特殊标记一下。一个优化求连通子图的方法是每个点与所有质因子相连边。  
时间复杂度 O(能过)。

## 2022/5/19

### first

用 bitset 优化找到 S 在 P 中出现的所有起始位置：  
bitset 预处理出所有小写字母 $x$ 在 P 中的位置集合 $ps(x)$，仅考虑 $S$ 中不为通配符的位置 $i$，所有 $ps (S_i) \operatorname{>>} (i-1)$ 并起来得到 S 出现的所有起始位置。  
复杂度 $O(\frac{n^2}{\omega})$。

### second

最大流 = 最小割，图是平面图，于是转化为求对偶图最短路。  
对偶图长得很特别：

```
 /- - - - -\ 
<| | | | | |>
 \- - - - -/
```

分为为两条主链，对应位置有连边。又由于边权均为正，因此最短路一定不会走回头路。可以划分成多个阶段求解并合并。每个阶段设 $f (0/1, 0/1)$ 表示边界是哪条主链，合并时格外计算有无切换主链的贡献。线段树维护即可。

### third

设 $f_i$ 表示 $1$ 到 $i$ 路径上的异色边数，有 $f_i = f_{fa_i} + [a_i \neq a_{fa_i}]$。答案即为 $\min_{\deg (i) = 1} \{ f_i \}$。

对于一次修改 $a_x \to y$，可能对三个子树中的 $f_i$ 造成 $\pm1$ 的贡献，分别是 $x$ 子树，$x$ 颜色为 $a_x$ 的儿子的子树和颜色为 $y$ 的儿子的子树。用平衡树维护 DFS 序，把颜色相同的儿子子树放到一起，每次修改就是 $O(1)$ 个区间加。改变 $a_x$ 时要同时改变 $x$ 子树在 $fa_x$ 子树中的位置，相当于 DFS 序上一次区间剪切。  
总时间复杂度 $O(n \log n)$。

## 2022/5/25

### 扑克牌谜题

$\max (a_i, a_j) = w$ 可以转化为 $a_i, a_j \leq w$，且两者至少有一个 $=w$；$min$ 限制同理。  
所有限制考虑完后每个 $a_i$ 有一个上下界 $[l_i, r_i]$。问题转化为在每个 $[l_i, r_i]$ 中选一个作为 $a_i$，并且满足所有限制 $(i, j)$，存在一个 $=w$。发现 $a_i$ 恰好取边界是最优的，即每个 $a_i$ 只有两种取值。用 2-sat 求出合法方案。

### 回文问题

两个串回文同构当且仅当所有同位子串同时为回文或同时不为。转化为所有前缀的极长回文后缀长度相同。  

考虑增量地构造 $T$：

* 如果 $S$ 中 $i$ 前缀的极长回文后缀长度 $>1$，只有一种方案。
* 否则，$T_i$ 不能与 $i-1$ 前缀的所有回文后缀的前一位相同。此时前缀 $i-1$ 的所有回文后缀均为极长回文串。可以证明回文同构的两串 $S, T$ 中所有前缀的回文后缀前一位的不等关系是一致的，在 $S$ 中找到总共的字符种类即可。

极长回文串总数 $O(n)$，manacher 求出所有贡献的位置，时间复杂度也为 $O(n)$。

### 疫情

先找到所有满足以下条件的边 $(u, v)$：  
删掉 $(u, v)$ 后，$u$ 所在连通块距离 $u$ 最远点到 $v$ 距离 $>k$ 且 $v$ 所在连通块距离 $v$ 最远点到 $u$ 距离 $>k$。  

标记所有这样边 $(u, v)$ 的端点。可以证明：所有被标记的点上都有医疗队 $\iff$ 合法。

贪心地给被标记的点匹配医疗队，定任一点为根，按到根距离降序匹配所有标记点，每次匹配当前标记点能匹配的医疗队中到根最远的，点分树维护匹配过程。

## 2022/5/26

### 简单顺序结构练习题

原题。

### 简单分支结构练习题

碰撞只会在相邻点之间发生，可能的答案总数是 $O(n)$ 的。枚举一个答案，小于答案的碰撞都不能发生，且答案对应的碰撞必须发生。可以通过 dp，二维状态 $f (i, 0/1)$ 来描述合法的概率。从小到大枚举答案，不能发生的碰撞单调增多，dp 的合法转移减少。dp 转移是相邻且线性的，用矩乘来描述，线段树来维护。

### 简单循环结构练习题

设 $f (n, k)$ 表示分成 $n$ 个 $k$ 边形的方案数。转移时枚举最小编号边所在 $k$ 边形的形态，可得：

$$
f (n, k) = \sum_{n_1 + n_2 + \dots n_{k-1} = n - 1}\prod_{i=1}^{k-1} f (n_i, k)
$$

上式即为长度为 $n(k-1)$ 的 (k-1)-Raney 序列的递推式，有通项公式

$$
\dbinom{n(k-1)+1}{n}\dfrac{1}{n(k-1)+1}
$$

## 2022/5/28

### City

一个性质：最优的两条路径，公共部分一定是连续的。  

首先预处理两点之间最短距离。  
对于一个固定的公共长度，非公共部分长度越小越好。可以 $O(n^2)$ 求出每个公共长度 $x$ 的最小非公共长度 $f_x$。  
然后对每个二元组 $(x, f_x)$ 求解最优答案，即分配 $k$ 给 $x$ 和 $f_x$ 的最优方案。假设分配方案为 $y, k-y$，大概是一个关于 $y$ 的二次函数，三分求最值。  
时间复杂度 $O(n^2 + n \log k)$。

### Button

暴力区间 DP 状态数 $O(n^2)$，注意到答案很小，把答案存进状态，求出向 左/右 延伸的范围 $l (x, c), r (x, c)$。其中 $l (x, c)$ 表示当前数字为 $x$，以 $c$ 的代价能确定的最远左端点。  

考虑转移：

$$
l (x, c) = \min_{r (y, c - dis (x, y) - 1) \geq x - 1} l (y, c - dis (x, y) - 1)
$$

平衡刷表和查表的复杂度，建立虚点辅助转移。具体的，数 `abcde` 连向 $2^5$ 个虚点，用 `?` 占据若干位，钦定占据的总位数为 $dis (x, y)$。维护每个虚点处的最优 dp 值，刷表和查表操作显然。错误的转移比正确转移劣，不影响最优转移的发生。

### Cake

每一维切的位置都可以调整到某个蛋糕该维的左端点，因此只需考虑所有左端点作为切点。

朴素的做法是枚举 $x$ 维切的位置 $X$，把所有满足 $rx < X$ 或 $lx > X$ 的蛋糕拿出来，再枚举 $y$ 维切的位置 $Y$，把 $ry < Y$ 和 $ly > Y$ 的蛋糕拿出来，把他们的 $[lz, rz]$ 和 $(-\infty, +\infty)$ 取交，如果交集不为空，即找到一组合法解。

考虑优化上述做法，对 $x$ 维线段树分治，根到 $X$ 对应的叶节点路径上就是所有 $rx < X$ 或 $lx > X$ 的蛋糕。对 $y$ 维建立线段树，每个结点维护对应 $y$ 维切点区间中有解位置的 $lz_{max}, rz_{min}$。线段树分治中加入一个蛋糕对应一次前后缀取 $min, max$，由于每次都是前后缀取 $min, max$，单个位置的 $lz_{max}, rz_{max}$ 分别是单谷和单峰函数，因此每次 $min, max$ 操作实质上是区间赋值，复杂度正确。线段树分治回溯时暴力撤回所有更改即可。

## 2022/5/30

### A

先对 T0 建点分树，然后对 T1 点分治，在当前分治中心，点 $x$ 到他的距离记为 $dt (x)$。点分树上每个点 $x$ 维护 $mi (x)$，表示子树中 $dt (u) + d_0 (x, u)$ 的最小值。顺序一个一个子树求解，加入子树时在每个点点分树上所有父亲更新 $mi$，查询也是如此，逆序再做一遍。  
因为此题要求距离最小值，错误的信息不会影响最优答案，正确性得到保证。

### B

要求字典序最大，肯定要从前往后尽量最大化每一位。  
但是如果一位一位地考虑没有前途，因为位与位之间独立性太弱，难以做到步步最优。换一种方式，最小化字典序大的字符位置及最大化数量。  
假设当前 `z` 有 $c$ 个连续段（忽略在字符串首位开始的段，因为如果有一定会选），如果 $k \geq c$，一定会把所有 `z` 段选上，当前位置变成最后一段的下一位，$k \gets k - c$，对子问题求解；否则，最优方案一定是在最大化 `z` 数量下最大化后缀字典序。从前往后枚举最后一段，并维护前 $k-1$ 段的最大长度，即可求出最优方案。

### C

钦定起点为 $(0, 0)$。
分析单个移动方式 $(a, b)$ 的移动范围，记 $d = \gcd (a, b)$。  
仅考虑 $x$ 维，根据裴蜀定理，最小的步长为 $d$，即能移动到 $(d, *)$ 的位置。对 $x$ 维执行一遍相同的操作，$y$ 维执行相反操作，就能移动到 $(2d, 0)$。同理可得，一定可以在一个单位长度为 $2d$ 的网格图中移动，下令 $d$ 为单位 $1$，等价于可以在一个单位长 $2$ 的网格图中移动，每次移动都不会改变坐标奇偶性。  
考虑其他奇偶性坐标的到达情况。记 $a_0 = \frac{a}{d}, b_0 = \frac{b}{d}$。  
* $a_0, b_0$ 一奇一偶，那么可以通过 $(a_0, b_0), (b_0, a_0)$ 移动到 (奇，偶) 和 (偶，奇) ，两者组合移动到 (奇，奇），再加上原点 (偶，偶）。根据已知合法的步长 $2$，能到达所有奇偶性相同的点，于是可达区域变成了一个单位长 $1$ 的网格图。
* $a_0, b_0$ 均为奇数。可以通过一次操作同时改变两个坐标的奇偶性，结合步长为 $2$ 即可以移动到所有奇偶性相同的点，可达区域为两张单位长 $2$ 的网格图的并。

根据上面的分析可知，一个可达区域可以表示为二元组 $(d, 0/1)$，$d$ 表示单位 $1$ 的长度，$0/1$ 表示可达区域的类型。分析两个区域的合并 $(dx, 0/1)$ 和 $(dy, 0/1)$。

* $(dx, 0)$ 和 $(dy, 0)$：合并为 $(\gcd (dx, dy), 0)$。
* $(dx, 0)$ 和 $(dy, 1)$：分为两步。首先 $(dx, 0)$ 和 $(2dy, 0)$ 合并为 $(rd \gets \gcd (dx, 2dy), 0)$。接着考虑移动方式 $(dy, dy)$ 的影响。已知 $rd \mid 2dy$，如果 $rd = 2dy$，移动方式 $(dy, dy)$ 使得可达区域变为 $(dy, 1)$；否则有 $rd \mid dy$，可达区域无变化。
* $(dx, 1)$ 和 $(dy, 1)$：类似地，分为两步。首先 $(2dx, 0)$ 和 $(2dy, 0)$ 合并为 $(rd \gets \gcd (2dx, 2dy), 0)$。接着考虑两个移动方式 $(dx, dx)$ 和 $(dy, dy)$ 的影响，与上种情况一致。

可达区域在合并时 $d$ 不变或缩减为因数，类型只存在 $0 \to 0, 0 \to 1$ 的变化。按照拓扑序转移更新即可。

## 2022/6/6

### 黑白沙漠

观察性质，对于一个确定的 $m$，满足 $x_i \leq m$ 的 $i$ 的生存时间为 $\frac{R-L}{m-L}(x_i - L) + y_i$，$x_i > m$ 的 $i$ 生存时间为 $\frac{R-l}{R - m}(R - x_i) + y_i$。  
仅考虑 $m$ 左边，给每个建筑赋坐标 $(x_i - L, y_i)$，活得最久的建筑一定在上凸壳，$m$ 在 $L \to R$ 的整个过程中，其左边活得最久的建筑最多发生 $O(n)$ 次变化，右边同理。  
找出所有的变化时间点，在相邻变化之间 $m$ 左右两边活得最久的建筑是确定的，在段内二分出两者答案分界。

## 2022/6/8

### 小孩召开法

发现一条合法的边 $(u, v)$ 满足 $highbit (u) < highbit (v)$，可得一条路径上的 $highbit$ 不断增大。$u \to v$ 的过程，新增了 $(highbit (u), highbit (v))$ 中的位，这些位置取值随意。$< highbit (u)$ 的位需要进行一次变化。  
合法的变化有 $0 \to 0, 0 \to 1, 1 \to 0$。因为 $highbit$ 不断增大，低位的取值不会影响大小关系的限制，所以低位变化是独立的。一个位置 $i$ 的变化次数为 $>i$ 位作为 $highbit$ 的数目，最终变化成 $T_i$。从高位往低位 DP，计算所有的路径数，复杂度 $O(n^2)$。

### 序列

基础贪心策略：$a_i \geq a_j$ 时 $b_i \geq b_j$。

将 $a$ 序列升序排序成 $a_1, a_2, \dots, a_n$。
对于任意一组 $b_i$ 都可以调整成一段 $b=n$ 的前缀 $i$，$b_{i + 1} = x$，和 $b$ 均相同的后缀 $i + 2$。

枚举这个 $i$，当前权值为：

$$
in + x + \lfloor \dfrac{D - n\sum_{j=1}^i a_j - xa_{i+1}}{\sum_{j=i + 2}^{m}a_j} \rfloor(m - i - 1 + k)
$$

后面是一个关于 $x$ 的函数 $f(x) = a\lfloor \frac{bx + c}{d} \rfloor(b < 0)$，图像呈锯齿状，极值点只有 $3$ 种可能，都 check 一下即可。

### 加油

$a_i \And b_i = c_i, a_i \mid b_i = d_i$，$(a_i, b_i)$ 和 $(a_i, c_i, d_i)$ 一一对应。转化为对 $c_i, d_i$ 计数，DP 即可。

## 2022/6/15

### 松鼠

一次操作 $x$ 相当于把 $x$ 定为根，所有非根点跳到父亲。根和所有 $>2$ 度点的儿子会进行合并。合并总次数是 $O(n)$ 的，所以每次合并可以暴力的做。用 LCT 辅助找到所有三度点的儿子们，合并采用启发式合并，注意对合并后的边集去重。

### 图

1. 类似线段树建图求出一颗内向树，$n-1$ 操作。  
2. 将根按入度升序询问所有点。
3. 将树黑白染色，相同颜色中不断合并入度最小的两个点，与 2 一起 $2 (n - 2)$ 次操作。
4. 最后剩下两个可能作为答案的点，询问一遍。$2(n - \log n)$ 次操作。

## 2022/6/16

### 游戏

转化为有向图游戏模型，可得 $SG (1) = 0, SG (x) = c (x) - 1 (x > 1)$，其中 $c (x)$ 为 $x$ 的质因子总数。答案即为 $\bigoplus_{i=1}^m SG (x_i) = 0$ 的数量。如果已知每种质因子数量对应的数个数，答案可以通过简单线性变换快速幂得到。  
求每种质因子数量对饮的数个数，Min25 筛即可。

### 灯泡

暴力的做法是对每个前缀 $i$ 用 bitset 维护亮灯位置集合 $s_i$，对于询问 $[l, r]$ 答案直接由 $s_{l-1} \oplus s_{r}$ 得到。这样做无法满足空间复杂度合法。  
对询问分块做，设块长为 $S$，空间复杂度为 $O(\frac{nS}{\omega})$，时间复杂度为 $O(\frac{n}{S}(n \log n + \frac{nS}{\omega}))$，取 $S = 3 \times 10^4$ 能够通过。