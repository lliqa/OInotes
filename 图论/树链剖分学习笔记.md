# 树链剖分

## 重链剖分

### 定义

1. 重儿子：一个结点儿子中**子树大小**最大的儿子。
2. 轻儿子：剩余的儿子。
3. 重边：结点到重儿子的边。
4. 轻边：除重边以外的边。

### 原理

将原树划分成若干条由重边首尾相连组成的重链。

### 性质

1. 树上每个结点**在且仅在一条**重链上。
2. 树上任意一条路径能够被拆分成 $\log_2 n$ 级条重链。
   > 证明：  
   > 只需证明树上任意一点到根的路径上的轻边数 $< \log_2 n$ 即可证明该性质。  
   > 由于轻儿子子树大小 $\leq$ 其子树大小一半，因此每经过一条轻边，子树大小至少减半。设点 $x$ 到根的路径上轻边数为 $k$，则 $\text{siz}(x) \leq \frac{n}{2^k}$ 。因为 $siz(x) > 0$ 所以 $k \leq \log_2 n$。



### 应用

#### 维护路径

运用性质 $1$，将路径拆分出的每一条重链信息合并。

</br>

#### 维护子树

根据 DFS序 将维护子树转化为维护区间。

</br>

#### 求 $\text{LCA}$

让所在链链首深度较大的点向上跳重链，重复至两点位于同一重链。此时深度较小结点即为 $\text{LCA}$ 。

正确性分类讨论可证。

参考代码：

```cpp
int LCA (int u, int v) {
  while (Top[u] != Top[v]) {
    if (Dep[Top[u]] > Dep[Top[v]])
      u = Fa[Top[u]];
    else
      v = Fa[Top[v]];
  } return Dep[u] > Dep[v] ? v : u;
}
```

## 长链剖分

### 定义

1. 重儿子：一个结点儿子中**子树中点深度最大**的儿子。
2. 轻儿子：剩余的儿子。
3. 重边：结点到重儿子的边。
4. 轻边：除重边以外的边。

### 原理

将原树划分成若干条由重边首尾相连组成的重链。

### 性质

1. 树上每个结点**在且仅在一条**重链上。
2. 树上一点的 $k$ 级祖先所在重链的长度 $> k$。
   > 证明：  
   > 设点 $x$ 的 $k$ 级祖先为 $y$，则 $\text{Len}(x, y) = k + 1$。因此，$y$ 点所在重链长度至少为 $k + 1$ 即 $> k$。
3. 树上任意一条点到根的路径最多有 $\sqrt{n}$ 条轻边。
   > 证明：  
   > 对于点 $x$，假设其到子树中结点最远距离为 $k$。若其父边为轻边，则子树大小至少为 $k + (k + 1)$。  
   > 因此如果经过了 $c$ 条轻边，则子树大小最少为 $\sum_{i=1}^{c + 1} i \approx c^2$。于是 $c \leq \sqrt{n}$。

### 应用

#### 求树上 $k$ 级祖先

可以做到 $O(n \log n)$ 预处理，$O(1)$ 查询。  
首先预处理出每个点的所有 $2^i$ 级父亲，设 $x = \lfloor \log_2 k \rfloor$ 即 $2^x \leq k < 2^{x+1}$，此时有 $k < 2^{x+1} \Rightarrow k - 2^x < 2^x$。  
根据性质 $2$，对于点 $a$ 的 $2^x$ 级祖先 $b$，其所在重链长度 $> 2^x > k - 2^x$。于是只要再预处理出每条重链链首向上 $len$ 个结点及向下 $len$ 个结点，就能快速回答询问。

#### 优化一类有 "深度" 维度的树形 DP。

对于此类 DP，每个点直接继承重儿子的 DP 值，并暴力合并轻儿子的 DP 值。  
因为继承是 $O(1)$，每条链只会在链首与其父亲处合并一次，为 $O(len)$，且 $\sum len = n$，所以总时间复杂度 $O(n)$。

> Q：为什么非要用长链剖分？直接乱剖不可以吗？  
> A：使用长链剖分是为了保证每条链的合并复杂度为 $O(len)$。若使用非长链剖分，对于重链 $x$，可能存在比其本身长的支链 $y$，则 $y$ 合并的复杂度为 $O(len_y)$， $x$ 合并的复杂度也为 $O(len_y)$。采用长链剖分则可以严格保证每条链合并的复杂度为 $O(len)$。

此外，在实现 $O(1)$ 继承重儿子的步骤上需要使用指针科技。