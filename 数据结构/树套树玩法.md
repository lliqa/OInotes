# 树套树玩法

## 一些约定

1. $n$ 为序列长度
2. $m$ 为操作数
3. $c$ 为值域大小

## 区间线段树套值域线段树

### 原理

略。

### 操作

#### 区间第 $K$ 小

1. 扒下区间线段树上组成查询区间的所有结点。(最多 $\log_2 n$)
2. 合并所有区间信息，在权值线段树上查询第 $K$ 小。$O (\log_2 n)$

总时间复杂度为 $O (\log^2_2 n)$

### 复杂度分析

略。

## 区间线段树套平衡树

### 原理

线段树维护区间，平衡树维护每一区间中的权值。

### 操作

#### 区间某值排名

1. 扒下线段树上所有组成区间。
2. 平衡树求出每一区间中小于待查询值的元素数量，其总和 $+1$ 即为答案

时间复杂度为 $O (\log^2_2 n)$

#### 区间第 $K$ 小

悲伤地发现像**区间线段树套值域线段树**中合并若干区间信息的做法对平衡树来说不太适用了，因为其信息的相加没有值域线段树那样方便、迅速 (直接每个结点取 $\sum$ 就行)。

不妨想想如何利用上文查询排名的应用。

1. 二分一个 $x$
2. 查询 $x$ 的区间排名
3. 根据排名调整二分。

不难发现时间复杂度多了一个 $O(\log_2 n)$ 也就是 $O(\log^3_2 n)$ 的。

## 树状数组套权值线段树

### 原理

树状数组维护每一个 $i$ 对应区间区间 $(i - \text{lowbit}(i), i]$，权值线段树维护区间信息。

由于外层是树状数组，因此最好用于处理单点修改问题。

### 操作

#### 区间第 $K$ 小

对于一个查询区间 $[l, r]$ ，利用差分的思想，用 $[1, r]$ 的信息减去 $[1, l - 1]$ 的信息。

查询就扒下组成 $[1, r]$ 和 $[1, l - 1]$ 的所有区间，在权值线段树上不停向下走查询第 $K$ 小就行。

时间复杂度是 $O (\log_2^2 n)$ 的，主要是线段树上递归的 $O (\log_2 n)$ 和扒下区间走左右儿子的 $O (log_2 n)$。

