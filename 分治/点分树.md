## 前置约定

1. $n$ 为点数。

## 树上分治

### 点分树

#### 原理

把点分治过程实化建树，即将每一层分治的重心连起来，得到了一颗深度**严格** $O(\log_2 n)$ 的树，称之为点分树。

#### 性质

1. 点分树上两点 $u, v$ 的 $\text{LCA} (u, v)$ 一定会出现在原树中两点的路径上。

	> 首先如果 $u, v$ 是祖先关系那么当然成立。
	>
	> 否则，说明在以点分树上 $\text{LCA} (u, v)$ 为重心分治时两点处于不同子树中，此时 $\text{LCA} (u, v)$ 也一定会出现在两点路径上。
	>
	> 证毕。

#### 应用

> 求树上距离点 $x$ 小于等于 $k$ 的所有点权和。

设 $\text{fa}_x$ 为 $x$ 在**点分树**上的父亲。

设 $\text{f} (x, k)$ 为 $x$ 在**点分树**上子树中距离 $x$ 小于等于 $k$ 的点权和。

设 $\text{g} (x, k)$ 为 $x$ 在**点分树**上子树中距离 $\text{fa}_x$ 小于等于 $k$ 的点权和。

请注意，上文中出现的 *距离* 均为**原树**上距离。

如何统计答案？

根据性质 $1$，我们可以不断地在**点分树**上跳 $fa_x$ ，然后统计经过当前点记为 $y$ 到达 $x$ 的合法路径数，但是需要容斥一下，减去一些不合法的路径 (均为非简单路径)，即 $y$ 子树中上来又下去的路径。

具体来说，对于 $x$ 及其**点分树**所有祖先 (除根以外) 构成的集合中的每一点 $y$ ，设 $\text{dis} (y, fa_y) = d$，则 $fa_y$ 对询问的贡献如下：
$$
f (fa_y, k - d) - g (y, k - d)
$$
不要忘记 $x$ 的贡献，所以最终结果还要加上 $f (x, k)$ 。

 