## 网格路径计数

1. 从 $(0, 0)$ 每次只能向上或向右走到 $(n, m)$ 的方案数：$\dbinom{n+m}{n}$
2. 从 $(0, 0)$ 每次只能向右上或右下走走到 $(n, m)$ 的方案数：$\dbinom{n}{\frac{n+m}2}$

### 翻折法

常用于解决一类有限制网格路径计数问题，不能触碰一条直线 $a$或两条**平行**线 $a, b$。假设起点为 $s$，终点为 $t$。

先考虑只有一条线 $a$ 的限制，尝试单步容斥：合法的路径数=总路径数-不合法路径数。总路径数容易求。考虑一条不合法路径，必然会经过 $a$ 若干次，把路径从第一次与 $a$ 相交的交点开始延 $a$ 翻折，相当于一条从 $s$ 到 $t$ 关于 $a$ 对称点 $t'$ 的路径。进一步可得不合法的路径和 $s$ 到 $t'$ 的路径构成双射。所以只需计算 $s$ 到 $t'$ 的路径数量即可。

然后考虑有两条线 $a, b$ 限制怎么做。  
考虑不合法路径长啥样，可以用依次经过的线来描述，例如 $\texttt{aabbabaaab}$，表示从起点依次触碰了哪条直线最后抵达终点。考虑容斥，枚举子序列 $\texttt{abab\dots}$（连续经过一条直线没有意义），然后计算一定包含这个子序列的路径数，乘上容斥系数 $(-1)^k$，$k$ 为子序列长度。枚举子序列可以用增量法，维护开头为 $a$ 和 $b$ 的两个序列，不断往后加即可。  
每个不合法路径不重不漏的证明用二项式定理。

https://www.cnblogs.com/hchhch233/p/10966468.html

---

## 分析

* 计数原理：构造若干便于计数的性质，计数分别满足这些性质的元素。
* 算重的原因：存在元素同时满足多个构造的性质。
* 防止算重的原理：构造恰当的性质使得不存在元素同时满足多个性质。

举例：  
代表元法：只在第一次满足某条件处统计贡献。“第一次满足条件的位置”即为构造的性质，一个元素不可能同时满足两个性质。

---

## 习题

* [[AGC019F] Yes or No](https://www.luogu.com.cn/problem/AT2705)

	> 首先转化为二维平面网格图问题. 有 $n$ 个 $Yes$ 与 $m$ 个 $No$ 等价于网格图上 $(n, m)$ 点. 目标是走到 $(0, 0)$ 点.
	>
	> 把答案序列看作是一条 $(n, m)$ 到 $(0, 0)$ 的折线. 最优策略当然是在 $n > m$ 时回答 $Yes$ , $n < m$ 时回答 $No$ . 至于 $n = m$ 时回答 $Yes/No$ 均可, 反正有 $\frac{1}{2}$ 的概率答对.
	>
	> 再把上述问题再次转化, 相当于在 $y = x$ 直线下方时统计答案序列向左走的次数, 在 $y = x$ 上方统计答案序列向下走的次数. 发现这样的次数总和恒为 $\max \left\{n, m\right\}$ . 但似乎少了点什么...在 $y = x$ 直线上呢? Easy, 统计经过 $y=x$ 的次数就行了.
	>
	> 根据期望的线性, 统计 $y = x$ 直线上每一点被经过的次数即可, 最后 $\times \frac{1}{2}$.
	
* [Bubble Sort](https://codeforces.com/gym/102222/problem/I)

	> 题意: 求 $n$ 个元素 $a_i$ 构成的所有排列中, 有多少个经过 $k$ 次冒泡排序之后, 基本有序. 基本有序指: 最长上升子序列的长度为 $n$ 或 $n−1$ .

	> 设 $F_i$ 表示下标在 $[1, i - 1]$ 中比 $a_i$ 大的数的个数.
	>
	> 手玩一下冒泡排序, 发现每一轮冒泡排序都会使得所有 $F_i$ 减一. 因为每一轮冒泡排序都会将最大值不断往前推, 第 $i$ 个位置的数恰好会和 $[1, i - 1]$ 中最大的数交换一次.
	>
	> 还有一个重要的性质, 排列与 $\left\{F_i\right\}$ 是一一对应的. 因为假设其长度为 $n$ , 那么 $F_n$ 能确定 $a_n$ 的排名, 继而确定 $a_{n-1}$ , 依此类推, 即可倒序确定唯一的 $a$ 数组. 同理可推知 $f_i + 1 \geq i$
	>
	> 于是问题转化为统计有多少个 $\left\{\max \left\{F_i-k, 0\right\}\right\}$ 对应着基本有序的序列.
	>
	> 基本有序的序列对应的 $\left\{F_i\right\}$ 长什么样呢?
	>
	> 1. 所有的 $F_i$ 均为 $0$ .
	> 2. 把已升序排列的序列中第 $i$ 个数插到 $j \ (j < i)$ 前, 使得 $F_x = 1 \ (x \in [j, i - 1])$
	> 3. 把已升序排列的序列中第 $i$ 个数插到 $j \ (j > i)$ 后, 使得 $F_i= j - i$
	>
	> 统计即可.

