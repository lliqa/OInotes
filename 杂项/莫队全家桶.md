# 莫队全家桶

## 前言

莫队，基于离线、分块的暴力做法，以根号凡人之躯挑战对数神明威严 :joy_cat:



## 正文

### 普通莫队

#### 形式

给一段长度为 $n$ 的序列与 $m$ 个区间询问。如果 $[l, r]$ 的答案能 $O(k)$ 地扩展到 $[l, r + 1]$ ，那么莫队能够以 $O(n\sqrt{m}k)$ 的时间复杂度求出所有询问答案。

#### 原理

分块 + 平衡复杂度。

首先最暴力的平方枚举不可取，在于其没有利用已求出区间的答案。

但如果只是单纯的每次移动 $l, r$ 指针而不加任何排序、优化，同样也会达到平方的复杂度。

莫队算法使用了对询问分块的方法。具体的，首先将区间分块，设块长为 $S$ ，共 $\frac{n}{S}$ 块。

排序方法如下：

1. 按 $l$ 所在块编号升序排序。

2. $l$ 所处块相同的询问按 $r$ 升序排序。

	奇偶性优化：$l$ 处在奇数块时升序排序，偶数块时降序。

然后暴力的转移区间答案，就能做到 $O(n \sqrt{m} k)$ 的复杂度。

#### 复杂度分析

设序列长度为 $n$，询问数为 $m$，块长为 $S$，块数为 $\frac{n}{S}$

$l$ 最多移动 $mS$ 次。(反复横跳，此次移动 $S$ 次)

$r$ 最多移动 $\frac{n^2}{S}$ 次。(由于右端点升序处理，每次最多移动 $n$ 次，有 $\frac{n}{S}$ 次。)

不同块之间的转移最多移动 $n + \frac{n^2}{S}$ 次，在使用奇偶性优化后可忽略。

于是总复杂度为 $O(\frac{n^2}{S} + mS) \geq 2 \times \sqrt{n^2m} = 2n\sqrt{m}$ ，忽略常数，在 $S = \frac{n}{\sqrt{m}}$ 时复杂度达到下界。

又因为单次移动时间复杂度为 $O(k)$ ，因此总复杂度为 $O(n\sqrt{m}k)$。

提供一个新的分析：

将询问看作二维平面上的点 $(l, r)$ ，优化时间复杂度相当于最小化 $m$ 个点的曼哈顿距离，曼哈顿最小生成树的权值即为最优时间复杂度。

对 $l$ 分块相当于将平面分成若干区域：

![](D:\XuanYuChen\Documents\LCs\notes\数据结构\md1.svg)

如图，每一区域按 $r$ 奇偶排序。这样看起来莫队的时间复杂度就呼之欲出了。

#### 实现细节

1. 排序奇偶性优化 (上文已提到)。

2. 四个循环位置

	```cpp
	    while (l > a[i].l) add(c[--l]);
	    while (r < a[i].r) add(c[++r]);
	    while (l < a[i].l) del(c[l++]);
	    while (r > a[i].r) del(c[r--]);
	```

	为保证在任意时刻 $l \leq r$ ，上面的四个循环应遵循先扩大区间即 ```l--,r++``` 后缩小区间即 ```l++,r--``` 的顺序进行。



### 带修莫队

#### 形式

普通莫队的问题再加上修改操作。

#### 原理

给普通的莫队加上一维，每次询问 $[l, r, k]$ 表示处理经过前 $k$ 次操作后的 $[l, r]$ 。

排序方法：

1. 按 $l$ 所在块编号升序排序。

2. $l$ 所处块相同的询问按 $r$ 所在块编号升序排序。

3. $l, r$ 所处快均相同则按 $k$ 升序排序。

	同样也能奇偶性优化。

#### 复杂度分析

设序列长度为 $n$，操作数为 $m$，块长为 $S$，块数为 $\frac{n}{S}$

$l, r$ 块相同，$k$ 移动：$(\frac{n}{S})^2m$ 次。每次移动满时间，共移动 $(\frac{n}{S})^2$ 次。

$l$ 块相同，$r$ 移动：$mS$ 次。共 $m$ 次操作，反复横跳满 $S$ 次移动。

$l$ 移动：$mS$ 次。同 $r$ 移动。

同样忽略不同块之间的转移复杂度。

总复杂度为 $O(2mS + (\frac{n}{S})^2m) \geq 4\sqrt{\frac{n^2m^2}{S}}$ ，忽略常数并化简得 $\frac{nm}{\sqrt{S}}$ 当且仅当 $mS = (\frac{n}{S})^2m$ 即 $S=n^{\frac{2}{3}}$ 时取等号。此时复杂度为 $O(n^{\frac{2}{3}}m)$ 。

同样的从数形结合的角度来分析：

一共有三维，对其中两维分块，同块中的点在这两维上每次最多移动 $2S$，共 $m$ 个点，也就是 $2mS$ 次。第三维升序排序最多移动块数乘长度，也就是 $(\frac{n}{S})^2m$。



#### 实现细节

1. 四个循环变成了六个循环。
2. 撤回修改操作直接在执行完修改以后再加入一个新的反修改操作即可。

### 高维莫队

#### 形式

有 $k$ 维的莫队

#### 原理

对前 $k - 1$ 维分块排序，对第 $k$ 维直接排序

#### 复杂度分析

具体证明略。时间复杂度 $O(n^{\frac{k-1}{k}}m)$


### 回滚莫队

#### 形式

对于一类问题如区间众数，扩展区间更新答案容易，但缩小区间更新答案就难以快速完成。

#### 原理

回滚莫队是普通莫队的魔改版。

其排序与普通莫队无异，在统计答案时，回滚莫队暴力处理 $l, r$ 同块的询问。对于 $l, r$ 不同块的询问，以 $l$ 所在块分类：

对于 $l$ 同块的询问，其 $r$ 已升序排序。(不能奇偶性优化)

首先将当前的区间指针 $L$ 设为块的末尾加一，$R$ 设为块的末尾。 意味着一个空区间。

每次暴力扩展一个询问，然后将 $L$ 指针撤回到初始位置。由于 $r$ 升序，故 $R$ 不动。

#### 复杂度分析

不难发现，回滚莫队只不过比普通莫队更接近复杂度上界而已。

#### 实现细节

1. 由于需要对每个块的询问分别处理，因此需要清空数组。而直接 ```memset``` 的复杂度过大，可以记录一下修改过的地方，然后清空。



### 树上莫队

#### 形式

就是莫队适用的序列问题搬到树上，一般询问是一条链。

#### 原理

* **欧拉序**：差不多就是括号序，与 DFS序 的不同在于欧拉序还会记录下回溯时的节点。即点 $i$ 第一次搜到时有一个时间戳 $l(i)$，回溯时又有一个 $r(i)$ 。

考虑如何提取出一条链。

将链分类，设 $u, v$ 为一条链的两端，那么能够分为两类：$u, v$ 为祖孙关系，$u, v$ 不为祖孙关系。

1. 考虑 $u, v$ 为祖孙关系，假设 $u$ 为 $v$ 祖先，那么 $[l (u), l (v)]$ 这段区间只保留出现一次的点即为 $(u, v)$ 这条链上的点。

	证明：

	一个欧拉序的性质，若 $a$ 为 $b$ 祖先，则 $l (a) < l (b) < r(b) < r(a)$ 。说明 $[l (u), l (v)]$ 中必然会保留 $(u, v)$ 链上点。考虑 $[l (u), l (v)]$ 中非 $v$ 祖先点 $k$，那么必定有 $l (k) < r(k) < l (v)$ ，否则 $k$ 为 $v$ 祖先。

2. $u, v$ 不为祖孙关系，假设 $l (u) < r (u) < l (v) < r (v)$，则 $[r (u), l (v)]$ 保留仅出现一次的点即为 $(u, v)$ 链上点 (除 $\mathrm{lca (u, v)}$ )。

	证明：

	设 $k = \mathrm{lca}(u, v)$

	同样利用上面的性质，$l (k) < r (u) < l (v) < r (k)$ 。首先发现 $k$ 是不会在区间内的。然后考虑将剩下的链上点分类，一类是 $u$ 的祖先，一类是 $v$ 的祖先。对于 $u$ 的祖先 $x$，有 $r (u) < r (x)$，会保留；对于 $v$ 的祖先，有 $l (v) < l (v)$ ，会保留。


#### 复杂度分析

同普通莫队

#### 实现细节

1. ```Add``` 与 ```Del``` 可以合并成一个函数，因为每个数只会出现 $0, 1, 2$ 次，贡献也只有 $0, 1$ ，异或一下就行。
2. ```Query``` 结构体记得记录 ```LCA```



## 扩展

### 值域分块

#### 应用

离线多次查询区间第 $K$ 大。