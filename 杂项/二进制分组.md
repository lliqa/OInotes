[TOC]

## 介绍

一种平衡复杂度的方法。
常用于强制在线的问题，一般有插入\查询操作，用某种数据结构维护当前所有已插入元素（假设有 $n$ 个）信息，查询时在该数据结构上查询给出元素需要的信息。信息要求有可加性。

## 原理
二进制分组的方法是把 $n$ 二进制分解，最多 $\log n$ 个 $2$ 的次幂。把已插入元素根据分解信息分成 $\log n$ 个组，每组大小等于对应的 $2$ 的次幂。对每一组分别维护数据结构，查询时在每一组的数据结构上分别查询，然后累加信息。插入时模拟 $n \to n + 1$ 的二进制下进位操作，具体来说，先对新插入的元素单独分一组，然后从小到大不断合并大小相同的组。


## 复杂度

设数据结构上单次查询复杂度为 $O(x)$，那么二进制分组每次查询的复杂度就是 $O(x\log n)$。

设插入、合并的复杂度均为为 $O(y\sum {s_i})$，$s$ 为元素的信息量。  
每个元素所在组合并一次后组大小就会翻倍，因此每个元素会被合并 $O(\log n)$ 次，总复杂度为 $O(y\sum {s_i} \log n)$

## 应用方向

单次插入复杂度过高，插入复杂度与合并复杂度同阶。

## 例题

### [CF710F String Set Queries](https://www.luogu.com.cn/problem/CF710F)

由于贡献有可减性，可以不管删除操作，只研究插入操作和在线查询。

查询可以用 AC自动机做，但动态修改 AC自动机的转移图和 fail树的复杂度过高。暴力做查询复杂度是 $O(\sum|S|)$，插入为 $O(m\sum {|s_i|})$。  
一个用来平衡这种强制在线复杂度的做法叫“二进制分组”。大概思路是维护 $\log n$ 个自动机，自动机大小分配就是当前串数的二进制分解。查询时在每个自动机上都做一遍，插入串时仅对该串建 AC自动机，然后不断合并相同大小的自动机，模拟串数 + 1 时的所有进位操作。  
然后分析复杂度：查询 $O(\sum|S| \log n)$。每次合并自动机的复杂度是 $O(\sum {|s_i|})$，因为每个串所在自动机合并一次后大小就翻倍，所以每个串最多被合并 $\log n$ 次，总插入复杂度是 $O(\sum {|s_i|} \log n)$